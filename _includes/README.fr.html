<div class='toc'>
	<ol class='level-1'>
		<li><a href='#Routes'>Routes</a></li>
		<ol class='level-2'>
			<li><a href='#Conditions'>Conditions</a></li>
			<li><a href='#Valeurs%20de%20retour'>Valeurs de retour</a></li>
			<li><a href='#Masques%20de%20route%20spcifiques'>Masques de route spcifiques</a></li>
		</ol>
		<li><a href='#Fichiers%20statiques'>Fichiers statiques</a></li>
		<li><a href='#Vues%20/%20Templates'>Vues / Templates</a></li>
		<ol class='level-2'>
			<li><a href='#Langages%20de%20template%20disponibles'>Langages de template disponibles</a></li>
			<li><a href='#Templates%20Haml'>Templates Haml</a></li>
			<li><a href='#Templates%20Erb'>Templates Erb</a></li>
			<li><a href='#Templates%20Builder'>Templates Builder</a></li>
			<li><a href='#Templates%20Nokogiri'>Templates Nokogiri</a></li>
			<li><a href='#Templates%20Sass'>Templates Sass</a></li>
			<li><a href='#Templates%20SCSS'>Templates SCSS</a></li>
			<li><a href='#Templates%20Less'>Templates Less</a></li>
			<li><a href='#Templates%20Liquid'>Templates Liquid</a></li>
			<li><a href='#Templates%20Markdown'>Templates Markdown</a></li>
			<li><a href='#Templates%20Textile'>Templates Textile</a></li>
			<li><a href='#Templates%20RDoc'>Templates RDoc</a></li>
			<li><a href='#Templates%20Radius'>Templates Radius</a></li>
			<li><a href='#Templates%20Markaby'>Templates Markaby</a></li>
			<li><a href='#Templates%20RABL'>Templates RABL</a></li>
			<li><a href='#Templates%20Slim'>Templates Slim</a></li>
			<li><a href='#Templates%20Creole'>Templates Creole</a></li>
			<li><a href='#Templates%20CoffeeScript'>Templates CoffeeScript</a></li>
			<li><a href='#Templates%20Yajl'>Templates Yajl</a></li>
			<li><a href='#Templates%20WLang'>Templates WLang</a></li>
			<li><a href='#Templates%20embarqus'>Templates embarqus</a></li>
			<li><a href='#Accder%20aux%20variables%20dans%20un%20Template'>Accder aux variables dans un Template</a></li>
			<li><a href='#Templates%20dans%20le%20fichier%20source'>Templates dans le fichier source</a></li>
			<li><a href='#Templates%20nomms'>Templates nomms</a></li>
			<li><a href='#Associer%20des%20extensions%20de%20fichier'>Associer des extensions de fichier</a></li>
			<li><a href='#Ajouter%20son%20propre%20moteur%20de%20rendu'>Ajouter son propre moteur de rendu</a></li>
		</ol>
		<li><a href='#Filtres'>Filtres</a></li>
		<li><a href='#Helpers'>Helpers</a></li>
		<ol class='level-2'>
			<li><a href='#Utiliser%20les%20sessions'>Utiliser les sessions</a></li>
			<li><a href='#Halt'>Halt</a></li>
			<li><a href='#Passer'>Passer</a></li>
			<li><a href='#Dclencher%20une%20autre%20route'>Dclencher une autre route</a></li>
			<li><a href='#Dfinir%20le%20corps,%20le%20code%20retour%20et%20les%20enttes'>Dfinir le corps, le code retour et les enttes</a></li>
			<li><a href='#Faire%20du%20streaming'>Faire du streaming</a></li>
			<li><a href='#Journalisation%20(Logging)'>Journalisation (Logging)</a></li>
			<li><a href='#Types%20Mime'>Types Mime</a></li>
			<li><a href='#Former%20des%20URLs'>Former des URLs</a></li>
			<li><a href='#Redirection%20du%20navigateur'>Redirection du navigateur</a></li>
			<li><a href='#Contrle%20du%20cache'>Contrle du cache</a></li>
			<li><a href='#Envoyer%20des%20fichiers'>Envoyer des fichiers</a></li>
			<li><a href='#Accder%20%20l&%2339;objet%20requte'>Accder  l&#39;objet requte</a></li>
			<li><a href='#Fichiers%20joints'>Fichiers joints</a></li>
			<li><a href='#Grer%20Date%20et%20Time'>Grer Date et Time</a></li>
			<li><a href='#Chercher%20les%20fichiers%20de%20templates'>Chercher les fichiers de templates</a></li>
		</ol>
		<li><a href='#Configuration'>Configuration</a></li>
		<ol class='level-2'>
			<li><a href='#Se%20protger%20des%20attaques'>Se protger des attaques</a></li>
			<li><a href='#Paramtres%20disponibles'>Paramtres disponibles</a></li>
		</ol>
		<li><a href='#Environements'>Environements</a></li>
		<li><a href='#Grer%20les%20erreurs'>Grer les erreurs</a></li>
		<ol class='level-2'>
			<li><a href='#NotFound'>NotFound</a></li>
			<li><a href='#Error'>Error</a></li>
		</ol>
		<li><a href='#Les%20Middlewares%20Rack'>Les Middlewares Rack</a></li>
		<li><a href='#Tester'>Tester</a></li>
		<li><a href='#Sinatra::Base%20-%20Les%20Middlewares,%20Bibliothques,%20et%20Applications%20Modulaires'>Sinatra::Base - Les Middlewares, Bibliothques, et Applications Modulaires</a></li>
		<ol class='level-2'>
			<li><a href='#Style%20modulaire%20vs.%20style%20classique'>Style modulaire vs. style classique</a></li>
			<li><a href='#Servir%20une%20application%20modulaire'>Servir une application modulaire</a></li>
			<li><a href='#Utiliser%20une%20application%20de%20style%20classique%20avec%20un%20fichier%20config.ru'>Utiliser une application de style classique avec un fichier config.ru</a></li>
			<li><a href='#Quand%20utiliser%20un%20fichier%20config.ru%20?'>Quand utiliser un fichier config.ru ?</a></li>
			<li><a href='#Utiliser%20Sinatra%20comme%20Middleware'>Utiliser Sinatra comme Middleware</a></li>
			<li><a href='#Cration%20dynamique%20d&%2339;applications'>Cration dynamique d&#39;applications</a></li>
		</ol>
		<li><a href='#Contextes%20et%20Binding'>Contextes et Binding</a></li>
		<ol class='level-2'>
			<li><a href='#Contexte%20de%20l&%2339;application/classe'>Contexte de l&#39;application/classe</a></li>
			<li><a href='#Contexte%20de%20la%20requte/instance'>Contexte de la requte/instance</a></li>
			<li><a href='#Le%20contexte%20de%20dlgation'>Le contexte de dlgation</a></li>
		</ol>
		<li><a href='#Ligne%20de%20commande'>Ligne de commande</a></li>
		<li><a href='#Configuration%20ncessaire'>Configuration ncessaire</a></li>
		<li><a href='#Essuyer%20les%20pltres'>Essuyer les pltres</a></li>
		<ol class='level-2'>
			<li><a href='#Avec%20Bundler'>Avec Bundler</a></li>
			<li><a href='#Faites%20le%20vous-mme'>Faites le vous-mme</a></li>
			<li><a href='#Installez%20globalement'>Installez globalement</a></li>
		</ol>
		<li><a href='#Versions'>Versions</a></li>
		<li><a href='#Mais%20encore'>Mais encore</a></li>
	</ol>
</div>


<p><em>Attention : Ce document correspond  la traduction de la version anglaise et
il n&#39;est peut tre plus  jour.</em></p>

<p>Sinatra est un <a href="http://fr.wikipedia.org/wiki/Langage_ddi">DSL</a> pour
crer rapidement et facilement des applications web en Ruby :</p>

<pre><code class="ruby"># mon_application.rb
require &#39;sinatra&#39;

get &#39;/&#39; do
  &#39;Bonjour le monde !&#39;
end
</code></pre>

<p>Installez la gem et lancez avec :</p>

<pre><code class="bash">$ gem install sinatra
$ ruby mon_application.rb
</code></pre>

<p>Le rsultat est visible sur : http://localhost:4567</p>

<p>Il est recommand d&#39;excuter galement <code>gem install thin</code>, pour que
Sinatra utilise le server Thin quand il est disponible.</p>

<a name='Routes'></a>
<h2>Routes</h2>

<p>Dans Sinatra, une route est une mthode HTTP couple  un masque (pattern)
URL. Chaque route est associe  un bloc :</p>

<pre><code class="ruby">get &#39;/&#39; do
  .. montrer quelque chose ..
end

post &#39;/&#39; do
  .. crer quelque chose ..
end

put &#39;/&#39; do
  .. remplacer quelque chose ..
end

patch &#39;/&#39; do
  .. changer quelque chose ..
end

delete &#39;/&#39; do
  .. effacer quelque chose ..
end

options &#39;/&#39; do
  .. apaiser quelquechose ..
end
</code></pre>

<p>Les routes sont values  dans l&#39;ordre o elles ont t dfinies. La premire
route qui correspond  la requte est appele.</p>

<p>Les masques peuvent inclure des paramtres nomms, accessibles par
l&#39;intermdiaire du hash <code>params</code> :</p>

<pre><code class="ruby">get &#39;/bonjour/:nom&#39; do
  # rpond aux requtes &quot;GET /bonjour/foo&quot; et &quot;GET /bonjour/bar&quot;
  # params[:nom] est &#39;foo&#39; ou &#39;bar&#39;
  &quot;Bonjour #{params[:nom]} !&quot;
end
</code></pre>

<p>Vous pouvez aussi accder aux paramtres nomms directement grce aux
paramtres du bloc comme ceci :</p>

<pre><code class="ruby">get &#39;/bonjour/:nom&#39; do |n|
  &quot;Bonjour #{n} !&quot;
end
</code></pre>

<p>Une route peut contenir un splat (caractre joker), accessible par
l&#39;intermdiaire du tableau <code>params[:splat]</code> :</p>

<pre><code class="ruby">get &#39;/dire/*/a/*&#39; do
  # rpond  /dire/bonjour/a/monde
  params[:splat] # =&gt; [&quot;bonjour&quot;, &quot;monde&quot;]
end

get &#39;/telecharger/*.*&#39; do
  # rpond  /telecharger/chemin/vers/fichier.xml
  params[:splat] # =&gt; [&quot;chemin/vers/fichier&quot;, &quot;xml&quot;]
end
</code></pre>

<p>Ou par l&#39;intermdiaire des paramtres du bloc :</p>

<pre><code class="ruby">get &#39;/telecharger/*.*&#39; do |chemin, ext|
  [chemin, ext] # =&gt; [&quot;path/to/file&quot;, &quot;xml&quot;]
end
</code></pre>

<p>Une route peut aussi tre dfinie par une expression rgulire :</p>

<pre><code class="ruby">get %r{/bonjour/([\w]+)} do
  &quot;Bonjour, #{params[:captures].first} !&quot;
end
</code></pre>

<p>L encore on peut utiliser les paramtres de bloc :</p>

<pre><code class="ruby">get %r{/bonjour/([\w]+)} do |c|
  &quot;Bonjour, #{c} !&quot;
end
</code></pre>

<p>Les routes peuvent aussi comporter des paramtres optionnels :</p>

<pre><code class="ruby">get &#39;/posts.?:format?&#39; do
  # rpond  &quot;GET /posts&quot; et aussi  &quot;GET /posts.json&quot;, &quot;GET /posts.xml&quot; etc...
end
</code></pre>

<p>A ce propos,  moins d&#39;avoir dsactiv la protection contre les attaques par
&quot;path transversal&quot; (voir plus loin), l&#39;URL demande peut avoir t modifie
avant d&#39;tre compare  vos routes.</p>

<a name='Conditions'></a>
<h3>Conditions</h3>

<p>Les routes peuvent dfinir toutes sortes de conditions, comme par exemple le
&quot;user agent&quot; :</p>

<pre><code class="ruby">get &#39;/foo&#39;, :agent =&gt; /Songbird (\d\.\d)[\d\/]*?/ do
  &quot;Vous utilisez Songbird version #{params[:agent][0]}&quot;
end

get &#39;/foo&#39; do
  # Correspond  tous les autres navigateurs
end
</code></pre>

<p>Les autres conditions disponibles sont <code>host_name</code> et <code>provides</code> :</p>

<pre><code class="ruby">get &#39;/&#39;, :host_name =&gt; /^admin\./ do
  &quot;Zone Administrateur, Accs refus !&quot;
end

get &#39;/&#39;, :provides =&gt; &#39;html&#39; do
  haml :index
end

get &#39;/&#39;, :provides =&gt; [&#39;rss&#39;, &#39;atom&#39;, &#39;xml&#39;] do
  builder :feed
end
</code></pre>

<p>Vous pouvez facilement dfinir vos propres conditions :</p>

<pre><code class="ruby">set(:probability) { |value| condition { rand &lt;= value } }

get &#39;/gagner_une_voiture&#39;, :probability =&gt; 0.1 do
  &quot;Vous avez gagn !&quot;
end

get &#39;/gagner_une_voiture&#39; do
  &quot;Dsol, vous avez perdu.&quot;
end
</code></pre>

<p>Utilisez un splat (caractre joker) dans le cas d&#39;une condition qui prend
plusieurs valeurs :</p>

<pre><code class="ruby">set(:auth) do |*roles|   # &lt;- ici on utilise un splat
  condition do
    unless logged_in? &amp;&amp; roles.any? {|role| current_user.in_role? role }
      redirect &quot;/login/&quot;, 303
    end
  end
end

get &quot;/mon/compte/&quot;, :auth =&gt; [:user, :admin] do
  &quot;Informations sur votre compte&quot;
end

get &quot;/reserve/aux/admins/&quot;, :auth =&gt; :admin do
  &quot;Seuls les administrateurs sont accepts ici !&quot;
end
</code></pre>

<a name='Valeurs%20de%20retour'></a>
<h3>Valeurs de retour</h3>

<p>La valeur renvoye par le bloc correspondant  une route constitue le corps de
la rponse qui sera transmise au client HTTP ou du moins au prochain middleware
dans la pile Rack. Le plus souvent, il s&#39;agit d&#39;une chane de caractres,
comme dans les exemples prcdents. Cependant, d&#39;autres valeurs sont
acceptes.</p>

<p>Vous pouvez renvoyer n&#39;importe quel objet qu&#39;il s&#39;agisse d&#39;une rponse Rack
valide, d&#39;un corps de rponse Rack ou d&#39;un code statut HTTP :</p>

<ul>
<li>Un tableau de 3 lments : <code>[code statut (Fixnum), enttes (Hash), corps
de la rponse (rpondant  #each)]</code></li>
<li>Un tableau de 2 lements : <code>[code statut (Fixnum), corps de la rponse
(rpondant  #each)]</code></li>
<li>Un objet qui rpond  <code>#each</code> et qui ne transmet que des chanes de
caractres au bloc fourni</li>
<li>Un Fixnum reprsentant le code statut</li>
</ul>

<p>Avec cela, on peut facilement implmenter un streaming par exemple :</p>

<pre><code class="ruby">class Stream
  def each
    100.times { |i| yield &quot;#{i}\n&quot; }
  end
end

get(&#39;/&#39;) { Stream.new }
</code></pre>

<p>Vous pouvez aussi utiliser le helper <code>stream</code> (prsent un peu plus loin) pour
viter la surcharge et intgrer le traitement relatif au streaming dans le bloc
de code de la route.</p>

<a name='Masques%20de%20route%20spcifiques'></a>
<h3>Masques de route spcifiques</h3>

<p>Comme cela a t vu auparavant, Sinatra offre la possibilit d&#39;utiliser des
masques sous forme de chaines de caractres ou des expressions rgulires
pour dfinir les routes. Mais il est possible de faire bien plus. Vous pouvez
facilement dfinir vos propres masques :</p>

<pre><code class="ruby">class MasqueToutSauf
  Masque = Struct.new(:captures)

  def initialize(except)
    @except   = except
    @captures = Masque.new([])
  end

  def match(str)
    @caputres unless @except === str
  end
end

def tout_sauf(masque)
  MasqueToutSauf.new(masque)
end

get tout_sauf(&quot;/index&quot;) do
  # ...
end
</code></pre>

<p>Notez que l&#39;exemple ci-dessus est bien trop compliqu et que le mme rsultat
peut tre obtenu avec :</p>

<pre><code class="ruby">get // do
  pass if request.path_info == &quot;/index&quot;
  # ...
end
</code></pre>

<p>Ou bien en utilisant la forme ngative :</p>

<pre><code class="ruby">get %r{^(?!/index$)} do
  # ...
end
</code></pre>

<a name='Fichiers%20statiques'></a>
<h2>Fichiers statiques</h2>

<p>Les fichiers du dossier <code>./public</code> sont servis de faon statique. Vous
avez la possibilit d&#39;utiliser un autre rpertoire en dfinissant le paramtre
<code>:public_folder</code> :</p>

<pre><code class="ruby">set :public_folder, File.dirname(__FILE__) + &#39;/statique&#39;
</code></pre>

<p>Notez que le nom du dossier public n&#39;apparait pas dans l&#39;URL. Le fichier
<code>./public/css/style.css</code> sera appel via l&#39;URL :
<code>http://exemple.com/css/style.css</code>.</p>

<p>Utilisez le paramtre <code>:static_cache_control</code> pour ajouter l&#39;information
d&#39;en-tte <tt>Cache-Control</tt> (voir plus loin).</p>

<a name='Vues%20/%20Templates'></a>
<h2>Vues / Templates</h2>

<p>Chaqie langage de template est disponible via sa propre mthode de rendu,
lesquelles renvoient tout simplement une chane de caractres.</p>

<pre><code class="ruby">get &#39;/&#39; do
  erb :index
end
</code></pre>

<p>Ceci effectue le rendu de la vue <code>views/index.erb</code>.</p>

<p>Plutt que d&#39;utiliser le nom d&#39;un template, vous pouvez directement passer
le contenu du template :</p>

<pre><code class="ruby">get &#39;/&#39; do
  code = &quot;&lt;%= Time.now %&gt;&quot;
  erb code
end
</code></pre>

<p>Les mthodes de templates acceptent un second paramtre, un hash d&#39;options :</p>

<pre><code class="ruby">get &#39;/&#39; do
  erb :index, :layout =&gt; :post
end
</code></pre>

<p>Ceci effectuera le rendu de la vue <code>views/index.erb</code> en l&#39;intgrant
au <em>layout</em> <code>views/post.erb</code> (les vues Erb sont intgres par dfaut
au <em>layout</em> <code>views/layout.erb</code> quand ce fichier existe).</p>

<p>Toute option que Sinatra ne comprend pas sera passe au moteur de rendu :</p>

<pre><code class="ruby">get &#39;/&#39; do
  haml :index, :format =&gt; :html5
end
</code></pre>

<p>Vous pouvez galement dfinir des options par langage de template de faon
gnrale :</p>

<pre><code class="ruby">set :haml, :format =&gt; html5

get &#39;/&#39; do
  haml :index
end
</code></pre>

<p>Les options passes  la mthode de rendu prennent le pas sur les options
dfinies au moyen de <code>set</code>.</p>

<p>Options disponibles :</p>

<p><strong>locals</strong>
  Liste de variables locales passes au document. Pratique pour les vues
  partielles.
  Exemple : <code>erb &quot;&lt;%= foo %&gt;&quot;, :locals =&gt; {:foo =&gt; &quot;bar&quot;}</code>.</p>

<p><strong>default_encoding</strong>
  Encodage de caractres  utiliser en cas d&#39;incertitude. Par dfaut, c&#39;est
  <code>settings.default_encoding</code>.</p>

<p><strong>views</strong>
  Dossier de vues dans lequel chercher les templates. Par dfaut
  <code>settings.views</code>.</p>

<p><strong>layout</strong>
  S&#39;il faut ou non utiliser un +layout+ (+true+ or +false+). Indique le
  template  utiliser lorsque c&#39;est un symbole. Exemple : <code>erb :index,
  :layout =&gt; !request.xhr?</code>.</p>

<p><strong>content_type</strong>
  Content-Type que le template produit, dpend par dfaut du langage de
  template.</p>

<p><strong>scope</strong>
  Contexte sous lequel effectuer le rendu du template. Par dfaut il s&#39;agit
  de l&#39;instance de l&#39;application. Si vous changez cela, les variables
  d&#39;instance et les mthodes utilitaires ne seront pas disponibles.</p>

<p><strong>layout_engine</strong>
  Moteur de rendu  utiliser pour le +layout+. Utile pour les langages ne
  supportant pas les +layouts+. Il s&#39;agit par dfaut du moteur utilis pour
  le rendu du template. Exemple : <code>set :rdoc, :layout_engine =&gt; :erb</code></p>

<p>Les templates sont supposs se trouver directement dans le dossier
<code>./views</code>. Pour utiliser un dossier de vues diffrent :</p>

<pre><code class="ruby">set :views, settings.root + &#39;/templates&#39;
</code></pre>

<p>Il est important de se souvenir que les templates sont toujours rfrencs
sous forme de symboles, mme lorsqu&#39;ils sont dans un sous-rpertoire (dans
ce cas, utilisez <code>:&#39;sous_repertoire/template&#39;</code>). Il faut utiliser
un symbole car les mthodes de rendu valuent le contenu des chanes de
caractres au lieu de les considrer comme un chemin vers un fichier.</p>

<a name='Langages%20de%20template%20disponibles'></a>
<h3>Langages de template disponibles</h3>

<p>Certains langages ont plusieurs implmentations. Pour prciser l&#39;implmentation
 utiliser (et garantir l&#39;aspect thread-safe), vous devez simplement l&#39;avoir
charge au pralable :</p>

<pre><code class="ruby">require &#39;rdiscount&#39; # ou require &#39;bluecloth&#39;
get(&#39;/&#39;) { markdown :index }
</code></pre>

<a name='Templates%20Haml'></a>
<h3>Templates Haml</h3>

<table>
  <tr>
    <td>Dpendances</td>
    <td><a href="http://haml.info/">haml</a></td>
  </tr>
  <tr>
    <td>Extensions de fichier</td>
    <td><tt>.haml</tt></td>
  </tr>
  <tr>
    <td>Exemple</td>
    <td><tt>haml :index, :format => :html5</tt></td>
  </tr>
</table>

<a name='Templates%20Erb'></a>
<h3>Templates Erb</h3>

<table>
  <tr>
    <td>Dpendances</td>
    <td><a href="http://www.kuwata-lab.com/erubis/">erubis</a> ou erb (inclus avec Ruby)</td>
  </tr>
  <tr>
    <td>Extensions de fichier</td>
    <td><tt>.erb</tt>, <tt>.rhtml</tt> ou <tt>.erubis</tt> (Erubis seulement)</td>
  </tr>
  <tr>
    <td>Exemple</td>
    <td><tt>erb :index</tt></td>
  </tr>
</table>

<a name='Templates%20Builder'></a>
<h3>Templates Builder</h3>

<table>
  <tr>
    <td>Dpendances</td>
    <td><a href="http://builder.rubyforge.org/">builder</a></td>
  </tr>
  <tr>
    <td>Extensions de fichier</td>
    <td><tt>.builder</tt></td>
  </tr>
  <tr>
    <td>Exemple</td>
    <td><tt>builder { |xml| xml.em "salut" }</tt></td>
  </tr>
</table>

<p>Ce moteur accepte galement un bloc pour des templates en ligne (voir
exemple).</p>

<a name='Templates%20Nokogiri'></a>
<h3>Templates Nokogiri</h3>

<table>
  <tr>
    <td>Dpendances</td>
    <td><a href="http://nokogiri.org/">nokogiri</a></td>
  </tr>
  <tr>
    <td>Extensions de fichier</td>
    <td><tt>.nokogiri</tt></td>
  </tr>
  <tr>
    <td>Exemple</td>
    <td><tt>nokogiri { |xml| xml.em "salut" }</p>
    </td>
  </tr>
</table>

<p>Ce moteur accepte galement un bloc pour des templates en ligne (voir
exemple).</p>

<a name='Templates%20Sass'></a>
<h3>Templates Sass</h3>

<table>
  <tr>
    <td>Dpendances</td>
    <td><a href="http://sass-lang.com/">sass</a></td>
  </tr>
  <tr>
    <td>Extensions de fichier</td>
    <td><tt>.sass</tt></td>
  </tr>
  <tr>
    <td>Exemple</td>
    <td><tt>sass :stylesheet, :style => :expanded</tt></td>
  </tr>
</table>

<a name='Templates%20SCSS'></a>
<h3>Templates SCSS</h3>

<table>
  <tr>
    <td>Dpendances</td>
    <td><a href="http://sass-lang.com/">sass</a></td>
  </tr>
  <tr>
    <td>Extensions de fichier</td>
    <td><tt>.scss</tt></td>
  </tr>
  <tr>
    <td>Exemple</td>
    <td><tt>scss :stylesheet, :style => :expanded</tt></p>
    </td>
  </tr>
</table>

<a name='Templates%20Less'></a>
<h3>Templates Less</h3>

<table>
  <tr>
    <td>Dpendances</td>
    <td><a href="http://www.lesscss.org/">less</a></td>
  </tr>
  <tr>
    <td>Extensions de fichier</td>
    <td><tt>.less</tt></td>
  </tr>
  <tr>
    <td>Exemple</td>
    <td><tt>less :stylesheet</tt>
    </td>
  </tr>
</table>

<a name='Templates%20Liquid'></a>
<h3>Templates Liquid</h3>

<table>
  <tr>
    <td>Dpendances</td>
    <td><a href="http://www.liquidmarkup.org/">liquid</a></td>
  </tr>
  <tr>
    <td>Extensions de fichier</td>
    <td><tt>.liquid</tt></td>
  </tr>
  <tr>
    <td>Exemple</td>
    <td><tt>liquid :index, :locals => { :key => 'value' }</tt></td>
  </tr>
</table>

<p>Comme vous ne pouvez appeler de mthodes Ruby (autres que <code>yield</code>)
dans un template Liquid, vous aurez srement  lui passer des variables
locales.</p>

<a name='Templates%20Markdown'></a>
<h3>Templates Markdown</h3>

<table>
  <tr>
    <td><p>Dpendances</p></td>
    <td><a href="https://github.com/rtomayko/rdiscount">rdiscount</a>, <a href="https://github.com/vmg/redcarpet">redcarpet</a>, <a href="http://deveiate.org/projects/BlueCloth">bluecloth</a>, <a href="http://kramdown.rubyforge.org/">kramdown</a> *ou* <a href="http://maruku.rubyforge.org/">maruku</a></td>
  </tr>

  <tr>
    <td>Extensions de fichier</td>
    <td><tt>.markdown</tt>, <tt>.mkd</tt> et <tt>.md</tt></td>
  </tr>
  <tr>
    <td>Exemple</td>
    <td><tt>markdown :index, :layout_engine => :erb</tt></td>
  </tr>
</table>

<p>Il nest pas possible dappeler des mthodes depuis markdown, ni de
lui passer des variables locales. Par consquent, il sera souvent utilis
en combinaison avec un autre moteur de rendu :</p>

<pre><code class="ruby">erb :overview, :locals =&gt; { :text =&gt; markdown(:introduction) }
</code></pre>

<p>Notez que vous pouvez galement appeler la mthode <code>markdown</code> au
sein dautres templates :</p>

<pre><code class="ruby">%h1 Hello From Haml !
%p= markdown(:greetings)
</code></pre>

<p>Comme vous ne pouvez pas appeler de Ruby au sein de Markdown, vous ne
pouvez pas utiliser de layouts crits en Markdown. Toutefois, il
est possible dutiliser un moteur de rendu diffrent pour le template et
pour le layout en utilisant loption <code>:layout_engine</code>.</p>

<a name='Templates%20Textile'></a>
<h3>Templates Textile</h3>

<table>
  <tr>
    <td>Dpendances</td>
    <td><a href="http://redcloth.org/">RedCloth</a></td>
  </tr>
  <tr>
    <td>Extensions de fichier</td>
    <td><tt>.textile</tt></td>
  </tr>
  <tr>
    <td>Exemple</td>
    <td><tt>textile :index, :layout_engine => :erb</tt></td>
  </tr>
</table>

<p>Il nest pas possible dappeler des mthodes depuis textile, ni de lui
passer des variables locales. Par consquent, il sera souvent utilis en
combinaison avec un autre moteur de rendu :</p>

<pre><code class="ruby">erb :overview, :locals =&gt; { :text =&gt; textile(:introduction) }
</code></pre>

<p>Notez que vous pouvez galement appeler la mthode <code>textile</code> au
sein dautres templates :</p>

<pre><code class="ruby">%h1 Hello From Haml !
%p= textile(:greetings)
</code></pre>

<p>Comme vous ne pouvez pas appeler de Ruby au sein de Textile, vous ne pouvez
pas utiliser de layouts crits en Textile. Toutefois, il est
possible dutiliser un moteur de rendu diffrent pour le template et
pour le layout en utilisant loption <code>:layout_engine</code>.</p>

<a name='Templates%20RDoc'></a>
<h3>Templates RDoc</h3>

<table>
  <tr>
    <td>Dpendances</td>
    <td><a href="http://rdoc.rubyforge.org/">rdoc</a></td>
  </tr>
  <tr>
    <td>Extensions de fichier</td>
    <td><tt>.rdoc</tt></td>
  </tr>
  <tr>
    <td>Exemple</td>
    <td><tt>rdoc :README, :layout_engine => :erb</tt></td>
  </tr>
</table>

<p>Il nest pas possible dappeler des mthodes depuis rdoc, ni de lui
passer des variables locales. Par consquent, il sera souvent utilis en
combinaison avec un autre moteur de rendu :</p>

<pre><code class="ruby">erb :overview, :locals =&gt; { :text =&gt; rdoc(:introduction) }
</code></pre>

<p>Notez que vous pouvez galement appeler la mthode <code>rdoc</code> au sein
dautres templates :</p>

<pre><code class="ruby">%h1 Hello From Haml !
%p= rdoc(:greetings)
</code></pre>

<p>Comme vous ne pouvez pas appeler de Ruby au sein de RDoc, vous ne pouvez
pas utiliser de layouts crits en RDoc. Toutefois, il est
possible dutiliser un moteur de rendu diffrent pour le template et
pour le layout en utilisant loption <code>:layout_engine</code>.</p>

<a name='Templates%20Radius'></a>
<h3>Templates Radius</h3>

<table>
  <tr>
    <td>Dpendances</td>
    <td><a href="http://radius.rubyforge.org/">radius</a></td>
  </tr>
  <tr>
    <td>Extensions de fichier</td>
    <td><tt>.radius</tt></td>
  </tr>
  <tr>
    <td>Exemple</td>
    <td><tt>radius :index, :locals => { :key => 'value' }</tt></td>
  </tr>
</table>

<p>Comme vous ne pouvez pas appeler de mthodes Ruby depuis un template
Radius, vous aurez srement  lui passer des variables locales.</p>

<a name='Templates%20Markaby'></a>
<h3>Templates Markaby</h3>

<table>
  <tr>
    <td>Dpendances</td>
    <td><a href="http://markaby.github.com/">markaby</a></td>
  </tr>
  <tr>
    <td>Extensions de fichier</td>
    <td><tt>.mab</tt></td>
  </tr>
  <tr>
    <td>Exemple</td>
    <td><tt>markaby { h1 "Bienvenue !" }</tt></td>
  </tr>
</table>

<p>Ce moteur accepte galement un bloc pour des templates en ligne (voir
exemple).</p>

<a name='Templates%20RABL'></a>
<h3>Templates RABL</h3>

<table>
  <tr>
    <td>Dpendances</td>
    <td><a href="https://github.com/nesquena/rabl">rabl</a></td>
  </tr>
  <tr>
    <td>Extensions de fichier</td>
    <td><tt>.rabl</tt></td>
  </tr>
  <tr>
    <td>Exemple</td>
    <td><tt>rabl :index</tt></td>
  </tr>
</table>

<a name='Templates%20Slim'></a>
<h3>Templates Slim</h3>

<table>
  <tr>
    <td>Dpendances</td>
    <td><a href="http://slim-lang.com/">slim</a></td>
  </tr>
  <tr>
    <td>Extensions de fichier</td>
    <td><tt>.slim</tt></td>
  </tr>
  <tr>
    <td>Exemple</td>
    <td><tt>slim :index</tt></td>
  </tr>
</table>

<a name='Templates%20Creole'></a>
<h3>Templates Creole</h3>

<table>
  <tr>
    <td>Dpendances</td>
    <td><a href="https://github.com/minad/creole">creole</a></td>
  </tr>
  <tr>
    <td>Extensions de fichier</td>
    <td><tt>.creole</tt></td>
  </tr>
  <tr>
    <td>Exemple</td>
    <td><tt>creole :wiki, :layout_engine => :erb</tt></td>
  </tr>
</table>

<p>Il n&#39;est pas possible d&#39;appeler des mthodes depuis markdown, ni de lui
passer des variables locales. Par consquent, il sera souvent utilis en
combinaison avec un autre moteur de rendu :</p>

<pre><code class="ruby">erb :overview, :locals =&gt; { :text =&gt; markdown(:introduction) }
</code></pre>

<p>Notez que vous pouvez galement appeler la mthode +markdown+ au sein d&#39;autres
templates :</p>

<pre><code class="ruby">%h1 Hello From Haml !
%p= markdown(:greetings)
</code></pre>

<p>Comme vous ne pouvez pas appeler de Ruby au sein de Markdown, vous ne pouvez
pas utiliser de +layouts+ crits en Markdown. Toutefois, il est possible
d&#39;utiliser un moteur de rendu diffrent pour le template et pour le +layout+
en utilisant l&#39;option <code>:layout_engine</code>.</p>

<a name='Templates%20CoffeeScript'></a>
<h3>Templates CoffeeScript</h3>

<table>
  <tr>
    <td>Dpendances</td>
    <td><a href="https://github.com/josh/ruby-coffee-script">coffee-script</a> et un [moyen d'excuter javascript](https://github.com/sstephenson/execjs/blob/master/README.md#readme)</td>
  </tr>
  <tr>
    <td>Extensions de fichier</td>
    <td><tt>.coffee</tt></td>
  </tr>
  <tr>
    <td>Exemple</td>
    <td><tt>coffee :index</tt></td>
  </tr>
</table>

<a name='Templates%20Yajl'></a>
<h3>Templates Yajl</h3>

<table>
  <tr>
    <td>Dpendances</td>
    <td><a href="https://github.com/brianmario/yajl-ruby">yajl-ruby</a></td>
  </tr>
  <tr>
    <td>Extensions de fichier</td>
    <td><tt>.yajl</tt></td>
  </tr>
  <tr>
    <td>Exemple</td>
    <td><tt>yajl :index, :locals => { :key => 'qux' }, :callback => 'present', :variable => 'resource'</tt></p>
    </td>
  </tr>
</table>

<p>Le source du template est valu en tant que chaine Ruby, puis la
variable json obtenue est convertie avec #to_json.</p>

<pre><code class="ruby">json = { :foo =&gt; &#39;bar&#39; }
json[:baz] = key
</code></pre>

<p>Les options <code>:callback</code> et <code>:variable</code> peuvent tre utilises pour dcorer lobjet retourn.</p>

<pre><code>var resource = {&quot;foo&quot;:&quot;bar&quot;,&quot;baz&quot;:&quot;qux&quot;}; present(resource);&lt;/pre&gt;
</code></pre>

<a name='Templates%20WLang'></a>
<h3>Templates WLang</h3>

<table>
  <tr>
    <td>Dependency</td>
    <td><a href="https://github.com/blambeau/wlang/">wlang</a></td>
  </tr>
  <tr>
    <td>File Extensions</td>
    <td><tt>.wlang</tt></td>
  </tr>
  <tr>
    <td>Example</td>
    <td><tt>wlang :index, :locals => { :key => 'value' }</tt></td>
  </tr>
</table>

<p>Lappel de code ruby au sein des templates nest pas idiomatique en wlang. Lcriture de templates sans logique est encourag, via le passage de variables locales. Il est nanmoins possible dcrire un layout en wlang et dy utiliser <code>yield</code>.</p>

<a name='Templates%20embarqus'></a>
<h3>Templates embarqus</h3>

<pre><code class="ruby">get &#39;/&#39; do
  haml &#39;%div.title Bonjour le monde&#39;
end
</code></pre>

<p>Gnrera le code du template spcifi dans la chane de caractres.</p>

<a name='Accder%20aux%20variables%20dans%20un%20Template'></a>
<h3>Accder aux variables dans un Template</h3>

<p>Un template est valu dans le mme contexte que l&#39;endroit d&#39;o il a t
appel (gestionnaire de route). Les variables d&#39;instance dclares dans le
gestionnaire de route sont directement accessibles dans le template :</p>

<pre><code class="ruby">get &#39;/:id&#39; do
  @foo = Foo.find(params[:id])
  haml &#39;%h1= @foo.nom&#39;
end
</code></pre>

<p>Alternativement, on peut passer un hash contenant des variables locales :</p>

<pre><code class="ruby">get &#39;/:id&#39; do
  foo = Foo.find(params[:id])
  haml &#39;%h1= foo.nom&#39;, :locals =&gt; { :foo =&gt; foo }
end
</code></pre>

<p>Ceci est gnralement utilis lorsque l&#39;on veut utiliser un template comme
partiel (depuis un autre template) et qu&#39;il est donc ncessaire d&#39;adapter les
noms de variables.</p>

<a name='Templates%20dans%20le%20fichier%20source'></a>
<h3>Templates dans le fichier source</h3>

<p>Des templates peuvent tre dfinis dans le fichier source comme ceci :</p>

<pre><code class="ruby">require &#39;sinatra&#39;

get &#39;/&#39; do
  haml :index
end

__END__

@@ layout
%html
  = yield

@@ index
%div.title Bonjour le monde !
</code></pre>

<p>NOTE : Les templates du fichier source qui contient <code>require &#39;sinatra&#39;</code>
sont automatiquement chargs. Si vous avez des templates dans d&#39;autres
fichiers source, il faut explicitement les dclarer avec
<code>enable :inline_templates</code>.</p>

<a name='Templates%20nomms'></a>
<h3>Templates nomms</h3>

<p>Les templates peuvent aussi tre dfinis grce  la mthode de haut niveau <code>template</code> :</p>

<pre><code class="ruby">template :layout do
  &quot;%html\n  =yield\n&quot;
end

template :index do
  &#39;%div.title Bonjour le monde !&#39;
end

get &#39;/&#39; do
  haml :index
end
</code></pre>

<p>Si un template nomm &quot;layout&quot; existe, il sera utilis  chaque fois qu&#39;un
template sera affich. Vous pouvez dsactivez les layouts au cas par cas en
passant <code>:layout =&gt; false</code> ou bien les dsactiver par dfaut au moyen
de <code>set :haml, :layout =&gt; false</code> :</p>

<pre><code class="ruby">get &#39;/&#39; do
  haml :index, :layout =&gt; !request.xhr?
end
</code></pre>

<a name='Associer%20des%20extensions%20de%20fichier'></a>
<h3>Associer des extensions de fichier</h3>

<p>Pour associer une extension de fichier avec un moteur de rendu, utilisez
<code>Tilt.register</code>. Par exemple, si vous dsirez utiliser l&#39;extension
de fichier <code>tt</code> pour les templates Textile, vous pouvez faire comme suit :</p>

<pre><code class="ruby">Tilt.register :tt, Tilt[:textile]
</code></pre>

<a name='Ajouter%20son%20propre%20moteur%20de%20rendu'></a>
<h3>Ajouter son propre moteur de rendu</h3>

<p>En premier lieu, dclarez votre moteur de rendu avec Tilt, ensuite crez
votre mthode de rendu :</p>

<pre><code class="ruby">Tilt.register :monmoteur, MonMerveilleurMoteurDeRendu

helpers do
  def monmoteur(*args) render(:monmoteur, *args) end
end

get &#39;/&#39; do
  monmoteur :index
end
</code></pre>

<p>Utilisera <code>./views/index.monmoteur</code>. Voir <a href="https://github.com/rtomayko/tilt">le dpt Github</a> pour en savoir plus sur Tilt.</p>

<a name='Filtres'></a>
<h2>Filtres</h2>

<p>Les filtres before sont excuts avant chaque requte, dans le mme contexte
que les routes, et permettent de modifier la requte et sa rponse. Les
variables d&#39;instance dclares dans les filtres sont accessibles au niveau
des routes et des templates :</p>

<pre><code class="ruby">before do
  @note = &#39;Coucou !&#39;
  request.path_info = &#39;/foo/bar/baz&#39;
end

get &#39;/foo/*&#39; do
  @note #=&gt; &#39;Coucou !&#39;
  params[:splat] #=&gt; &#39;bar/baz&#39;
end
</code></pre>

<p>Les filtres after sont excuts aprs chaque requte  l&#39;intrieur du mme
contexte et permettent de modifier la requte et sa rponse. Les variables
d&#39;instance dclares dans les filtres before ou les routes sont accessibles
au niveau des filtres after :</p>

<pre><code class="ruby">after do
  puts response.status
end
</code></pre>

<p>Note : Le corps de la rponse n&#39;est pas disponible au niveau du filtre after
car il ne sera gnr que plus tard (sauf dans le cas o vous utilisez la
mthode +body+ au lieu de simplement renvoyer une chaine depuis vos routes).</p>

<p>Les filtres peuvent tre associs  un masque, ce qui permet de limiter leur
excution aux cas o la requte correspond  ce masque :</p>

<pre><code class="ruby">before &#39;/secret/*&#39; do
  authentification!
end

after &#39;/faire/:travail&#39; do |travail|
  session[:dernier_travail] = travail
end
</code></pre>

<p>Tout comme les routes, les filtres acceptent galement des conditions :</p>

<pre><code class="ruby">before :agent =&gt; /Songbird/ do
  # ...
end

after &#39;/blog/*&#39;, :host_name =&gt; &#39;example.com&#39; do
  # ...
end
</code></pre>

<a name='Helpers'></a>
<h2>Helpers</h2>

<p>Utilisez la mthode de haut niveau <code>helpers</code> pour dfinir des routines
qui seront accessibles dans vos gestionnaires de route et dans vos templates :</p>

<pre><code class="ruby">helpers do
  def bar(nom)
    &quot;#{nom}bar&quot;
  end
end

get &#39;/:nom&#39; do
  bar(params[:nom])
end
</code></pre>

<p>Vous pouvez aussi dfinir les mthodes helper dans un module spar :</p>

<pre><code class="ruby">module FooUtils
  def foo(nom) &quot;#{nom}foo&quot; end
end

module BarUtils
  def bar(nom) &quot;#{nom}bar&quot; end
end

helpers FooUtils, BarUtils
</code></pre>

<p>Cela a le mme rsultat que d&#39;inclure les modules dans la classe de
l&#39;application.</p>

<a name='Utiliser%20les%20sessions'></a>
<h3>Utiliser les sessions</h3>

<p>Une session est utilise pour conserver un tat entre les requtes. Une fois
actives, vous avez un +hash+ de session par session utilisateur :</p>

<pre><code class="ruby">enable :sessions

get &#39;/&#39; do
  &quot;valeur = &quot; &lt;&lt; session[:valeur].inspect
end

get &#39;/:value&#39; do
  session[:valeur] = params[:valeur]
end
</code></pre>

<p>Notez que <tt>enable :sessions</tt> enregistre en fait toutes les donnes dans
un +cookie+. Ce n&#39;est pas toujours ce que vous voulez (enregistrer beaucoup de
donnes va augmenter le traffic par exemple). Vous pouvez utiliser n&#39;importe
quel +middleware+ Rack de session afin d&#39;viter cela. N&#39;utiliser <em>pas</em>
<tt>enable :sessions</tt> dans ce cas mais charger le +middleware+ de votre
choix comme vous le feriez pour n&#39;importe quel autre +middleware+ :</p>

<pre><code class="ruby">use Rack::Session::Pool, :expire_after =&gt; 2592000

get &#39;/&#39; do
  &quot;valeur = &quot; &lt;&lt; session[:valeur].inspect
end

get &#39;/:value&#39; do
  session[:valeur] = params[:valeur]
end
</code></pre>

<p>Pour renforcer la scurit, les donnes de session dans le cookie sont signes
avec une cl secrte de session. Une cl secrte est gnre pour vous au
hasard par Sinatra. Toutefois, comme cette cl change  chaque dmarrage de
votre application, vous pouvez dfinir cette cl vous-mme afin que toutes
les instances de votre application la partage :</p>

<pre><code class="ruby">set :session_secret, &#39;super secret&#39;
</code></pre>

<p>Si vous souhaitez avoir plus de contrle, vous pouvez galement enregistrer un
+hash+ avec des options lors de la configuration de <code>sessions</code> :</p>

<pre><code class="ruby">set :sessions, :domain =&gt; &#39;foo.com&#39;
</code></pre>

<a name='Halt'></a>
<h3>Halt</h3>

<p>Pour arrter immdiatement la requte dans un filtre ou un gestionnaire de
route :</p>

<pre><code class="ruby">halt
</code></pre>

<p>Vous pouvez aussi passer le code retour ...</p>

<pre><code class="ruby">halt 410
</code></pre>

<p>Ou le texte ...</p>

<pre><code class="ruby">halt &#39;Ceci est le texte&#39;
</code></pre>

<p>Ou les deux ...</p>

<pre><code class="ruby">halt 401, &#39;Partez !&#39;
</code></pre>

<p>Ainsi que les enttes ...</p>

<pre><code class="ruby">halt 402, {&#39;Content-Type&#39; =&gt; &#39;text/plain&#39;}, &#39;revanche&#39;
</code></pre>

<p>Bien sr il est possible de combiner un template avec <code>halt</code> :</p>

<pre><code class="ruby">halt erb(:erreur)
</code></pre>

<a name='Passer'></a>
<h3>Passer</h3>

<p>Une route peut passer le relais aux autres routes qui correspondent galement
avec <code>pass</code> :</p>

<pre><code class="ruby">get &#39;/devine/:qui&#39; do
  pass unless params[:qui] == &#39;Frank&#39;
  &quot;Tu m&#39;as eu !&quot;
end

get &#39;/devine/*&#39; do
  &#39;Manqu !&#39;
end
</code></pre>

<p>On sort donc immdiatement de ce gestionnaire et on continue  chercher,
dans les masques suivants, le prochain qui correspond  la requte.
Si aucun des masques suivants ne correspond, un code 404 est retourn.</p>

<a name='Dclencher%20une%20autre%20route'></a>
<h3>Dclencher une autre route</h3>

<p>Parfois, +pass+ n&#39;est pas ce que vous recherchez, au lieu de cela vous
souhaitez obtenir le rsultat d&#39;une autre route. Pour cela, utilisez
simplement call :</p>

<pre><code class="ruby">get &#39;/foo&#39; do
  status, headers, body = call env.merge(&quot;PATH_INFO&quot; =&gt; &#39;/bar&#39;)
  [status, headers, body.map(&amp;:upcase)]
end

get &#39;/bar&#39; do
  &quot;bar&quot;
end
</code></pre>

<p>Notez que dans l&#39;exemple ci-dessus, vous faciliterez les tests et amliorerez
la performance en dplaant simplement <code>&quot;bar&quot;</code> dans un helper
utilis  la fois par <code>/foo</code> et <code>/bar</code>.</p>

<p>Si vous souhiatez que la requte soit envoye  la mme instance de
l&#39;application plutt qu&#39; une copie, utilisez <code>call!</code> au lieu de
<code>call</code>.</p>

<p>Lisez la spcification Rack si vous souhaitez en savoir plus sur
<code>call</code>.</p>

<a name='Dfinir%20le%20corps,%20le%20code%20retour%20et%20les%20enttes'></a>
<h3>Dfinir le corps, le code retour et les enttes</h3>

<p>Il est possible et recommand de dfinir le code retour et le corps de la
rponse au moyen de la valeur de retour d&#39;un bloc dfinissant une route.
Quoiqu&#39;il en soit, dans certains cas vous pourriez avoir besoin de dfinir
le coprs de la rponse  un moment arbitraire de l&#39;excution. Vous pouvez le
faire au moyen de la mthode +body+. Si vous faites ainsi, vous pouvez alors
utiliser cette mme mthode pour accder au corps de la rponse :</p>

<pre><code class="ruby">get &#39;/foo&#39; do
  body &quot;bar&quot;
end

after do
  puts body
end
</code></pre>

<p>Il est galement possible de passer un bloc  <code>body</code>, qui sera excut par le
gestionnaire Rack (ceci peut tre utilis pour implmenter un streaming,
voir &quot;Valeurs de retour&quot;).</p>

<p>Pareillement au corps de la rponse, vous pouvez galement dfinir le code
retour et les enttes :</p>

<pre><code class="ruby">get &#39;/foo&#39; do
  status 418
  headers \
    &quot;Allow&quot;   =&gt; &quot;BREW, POST, GET, PROPFIND, WHEN&quot;,
    &quot;Refresh&quot; =&gt; &quot;Refresh: 20; http://www.ietf.org/rfc/rfc2324.txt&quot;
  body &quot;Je suis une thire !&quot;
end
</code></pre>

<p>Comme <code>body</code> <code>headers</code> et <code>status</code> peuvent tre utiliss sans arguments
pour accder  leurs valeurs.</p>

<a name='Faire%20du%20streaming'></a>
<h3>Faire du streaming</h3>

<p>Il y a des cas o vous voulez commencer  renvoyer des donnes pendant que
vous tes en train de gnrer le reste de la rponse. Dans les cas les plus
extrmes, vous souhaitez continuer  envoyer des donnes tant que le client
n&#39;abandonne pas la connection. Vous pouvez alors utiliser le helper <code>stream</code>
pour viter de crer votre propre systme :</p>

<pre><code class="ruby">get &#39;/&#39; do
  stream do |out|
    out &lt;&lt; &quot;Ca va tre hallu -\n&quot;
    sleep 0.5
    out &lt;&lt; &quot; (attends la suite) \n&quot;
    sleep 1
    out &lt;&lt; &quot;- cinant !\n&quot;
  end
end
</code></pre>

<p>Cela permet d&#39;implmenter des API de streaming ou de
<a href="http://dev.w3.org/html5/eventsource/">Server Sent Events</a> et peut servir de
base pour des <a href="http://en.wikipedia.org/wiki/WebSocket">WebSockets</a>. Vous
pouvez aussi l&#39;employer pour augmenter le dbit quand une partie du contenu
provient d&#39;une resource lente.</p>

<p>Le fonctionnement du streaming, notamment le nombre de requtes simultanes,
dpend normment du serveur web utilis. Certains ne prennent pas du tout en
charge le streaming (WEBRick par exemple). Lorsque le serveur ne gre pas le
streaming, la partie body de la rponse sera envoye au client en une seule
fois, aprs que l&#39;excution du bloc pass au helper +stream+ sera termine. Le
streaming ne fonctionne pas du tout avec Shotgun.</p>

<p>En utilisant le helper +stream+ avec le paramtre +keep_open+, il n&#39;appelera
pas la mthode +close+ du flux, vous laissant la possibilit de le fermer 
tout moment au cours de l&#39;excution. Ceci ne fonctionne qu&#39;avec les serveurs
evented (ie non threads) tels que Thin et Rainbows. Les autres serveurs
fermeront malgr tout le flux :</p>

<pre><code class="ruby">set :server, :thin
connections = []

get &#39;/&#39; do
  # conserve le flux ouvert
  stream(:keep_open) { |out| connections &lt;&lt; out }
end

post &#39;/&#39; do
  # crit dans tous les flux ouverts
  connections.each { |out| out &lt;&lt; params[:message] &lt;&lt; &quot;\n&quot; }
  &quot;message sent&quot;
end
</code></pre>

<a name='Journalisation%20(Logging)'></a>
<h3>Journalisation (Logging)</h3>

<p>Dans le contexte de la requte, la mthode utilitaire +logger+ expose une
instance de +logger+ :</p>

<pre><code class="ruby">get &#39;/&#39; do
  logger.info &quot;chargement des donnes&quot;
  # ...
end
</code></pre>

<p>Ce logger va automatiquement prendre en compte les paramtres de
configuration pour la journalisation de votre gestionnaire Rack. Si la
journalisation est dsactive, cette mthode renverra un objet factice et
vous n&#39;avez pas  vous en inquiter dans vos routes en le filtrant.</p>

<p>Notez que la journalisation est seulement active par dfaut pour
<code>Sinatra::Application</code>, donc si vous hritez de <code>&gt;Sinatra::Base</code>,
vous aurez  l&#39;activer vous-mme :</p>

<pre><code class="ruby">class MonApp &lt; Sinatra::Base
  configure :production, :development do
    enable :logging
  end
end
</code></pre>

<p>Si vous souhaitez utiliser votre propre logger, vous devez dfinir le paramtre
<code>logging</code>  <code>nil</code> pour tre certain qu&#39;aucun middleware de logging ne sera
install (notez toutefois que +logger+ renverra alors +nil+). Dans ce cas,
Sinatra utilisera ce qui sera prsent dans <code>env[&#39;rack.logger&#39;]</code>.</p>

<a name='Types%20Mime'></a>
<h3>Types Mime</h3>

<p>Quand vous utilisez <code>send_file</code> ou des fichiers statiques, vous
pouvez rencontrer des types mime que Sinatra ne connat pas. Utilisez
<code>mime_type</code> pour les dclarer par extension de fichier :</p>

<pre><code class="ruby">configure do
  mime_type :foo, &#39;text/foo&#39;
end
</code></pre>

<p>Vous pouvez galement les utiliser avec la mthode <code>content_type</code> :</p>

<pre><code class="ruby">get &#39;/&#39; do
  content_type :foo
  &quot;foo foo foo&quot;
end
</code></pre>

<a name='Former%20des%20URLs'></a>
<h3>Former des URLs</h3>

<p>Pour former des URLs, vous devriez utiliser la mthode +url+, par exemple en
Haml :</p>

<pre><code class="ruby">%a{:href =&gt; url(&#39;/foo&#39;)} foo
</code></pre>

<p>Cela prend en compte les proxy inverse et les routeurs Rack, s&#39;ils existent.</p>

<p>Cette mthode est galement disponible sous l&#39;alias +to+ (voir ci-dessous
pour un exemple).</p>

<a name='Redirection%20du%20navigateur'></a>
<h3>Redirection du navigateur</h3>

<p>Vous pouvez dclencher une redirection du navigateur avec la mthode
<code>redirect</code> :</p>

<pre><code class="ruby">get &#39;/foo&#39; do
  redirect to(&#39;/bar&#39;)
end
</code></pre>

<p>Tout paramtre additionnel est gr comme des arguments pour la mthode
<code>halt</code> :</p>

<pre><code class="ruby">redirect to(&#39;/bar&#39;), 303
redirect &#39;http://google.com&#39;, &#39;mauvais endroit mon pote&#39;
</code></pre>

<p>Vous pouvez aussi rediriger vers la page dont l&#39;utilisateur venait au moyen de
<code>redirect back</code> :</p>

<pre><code class="ruby">get &#39;/foo&#39; do
  &quot;&lt;a href=&#39;/bar&#39;&gt;faire quelque chose&lt;/a&gt;&quot;
end

get &#39;/bar&#39; do
  faire_quelque_chose
  redirect back
end
</code></pre>

<p>Pour passer des arguments  une redirection, ajoutez-les soit  la requte :</p>

<pre><code class="ruby">redirect to(&#39;/bar?sum=42&#39;)
</code></pre>

<p>Ou bien utilisez une session :</p>

<pre><code class="ruby">enable :sessions

get &#39;/foo&#39; do
  session[:secret] = &#39;foo&#39;
  redirect to(&#39;/bar&#39;)
end

get &#39;/bar&#39; do
  session[:secret]
end
</code></pre>

<a name='Contrle%20du%20cache'></a>
<h3>Contrle du cache</h3>

<p>Dfinir correctement vos enttes  la base pour un bon cache HTTP.</p>

<p>Vous pouvez facilement dfinir l&#39;entte Cache-Control de la manire suivante :</p>

<pre><code class="ruby">get &#39;/&#39; do
  cache_control :public
  &quot;met le en cache !&quot;
end
</code></pre>

<p>Conseil de pro : dfinir le cache dans un filtre +before+ :</p>

<pre><code class="ruby">before do
  cache_control :public, :must_revalidate, :max_age =&gt; 60
end
</code></pre>

<p>Si vous utilisez la mthode +expires+ pour dfinir l&#39;entte correspondant,
<code>Cache-Control</code> sera alors dfini automatiquement :</p>

<pre><code class="ruby">before do
  expires 500, :public, :must_revalidate
end
</code></pre>

<p>Pour utiliser correctement les caches, vous devriez utiliser +etag+ ou
+last_modified+. Il est recommand d&#39;utiliser ces mthodes <em>avant</em> de faire
d&#39;importantes modifications, car elles vont immdiatement dclencher la rponse
si le client a dj la version courante dans son cache :</p>

<pre><code class="ruby">get &#39;/article/:id&#39; do
  @article = Article.find params[:id]
  last_modified @article.updated_at
  etag @article.sha1
  erb :article
end
</code></pre>

<p>Il est galement possible d&#39;utiliser un
<a href="http://en.wikipedia.org/wiki/HTTP_ETag#Strong_and_weak_validation">weak ETag</a> :</p>

<pre><code class="ruby">etag @article.sha1, :weak
</code></pre>

<p>Ces mthodes ne sont pas charges de mettre des donnes en cache, mais elles
fournissent les informations ncessaires pour votre cache. Si vous tes  la
recherche de solutions rapides pour un reverse-proxy de cache, essayez
<a href="https://github.com/rtomayko/rack-cache">rack-cache</a> :</p>

<pre><code class="ruby">require &quot;rack/cache&quot;
require &quot;sinatra&quot;

use Rack::Cache

get &#39;/&#39; do
  cache_control :public, :max_age =&gt; 36000
  sleep 5
  &quot;hello&quot;
end
</code></pre>

<p>Utilisez le paramtre <code>:static_cache_control</code> pour ajouter l&#39;information
d&#39;en-tte <code>Cache-Control</code> (voir plus loin).</p>

<p>D&#39;aprs la RFC 2616, votre application devrait se comporter diffrement lorsque
l&#39;en-tte If-Match ou If-None-Match est dfini  <code>*</code> en tenant compte du
fait que la resource demande existe dj ou pas. Sinatra considre que les
requtes portant sur des resources sres (tel que get) ou idempotentes (tel que
put) existent dj et pour les autres resources (par exemple dans le cas
de requtes post) qu&#39;il s&#39;agit de nouvelles resources. Vous pouvez modifier ce
comportement en passant une option <code>:new_resource</code> :</p>

<pre><code class="ruby">get &#39;/create&#39; do
  etag &#39;&#39;, :new_resource =&gt; true
  Article.create
  erb :new_article
end
</code></pre>

<p>Si vous souhaitez utilisez un ETag faible, utilisez l&#39;option <tt>:kind</tt> :</p>

<pre><code>etag &#39;&#39;, :new_resource =&gt; true, :kind =&gt; :weak
</code></pre>

<a name='Envoyer%20des%20fichiers'></a>
<h3>Envoyer des fichiers</h3>

<p>Pour envoyer des fichiers, vous pouvez utiliser la mthode
<code>send_file</code> :</p>

<pre><code class="ruby">get &#39;/&#39; do
  send_file &#39;foo.png&#39;
end
</code></pre>

<p>Quelques options sont galement acceptes :</p>

<pre><code class="ruby">send_file &#39;foo.png&#39;, :type =&gt; :jpg
</code></pre>

<p>Les options sont :</p>

<dl>
  <dt>filename</dt>
  <dd>
    le nom du fichier dans la rponse, par dfaut le nom du fichier envoy.
  </dd>

  <dt>last_modified</dt>
  <dd>valeur pour lentte Last-Modified, par dfaut la date de modification
du fichier</dd>

  <dt>type</dt>
  <dd>type de contenu  utiliser, devin  partir de lextension de fichier
  si absent</dd>

  <dt>disposition</dt>
  <dd>utilis pour Content-Disposition, les valuers possibles tant :
  `nil` (par dfaut), `:attachment` et `:inline`</dd>

  <dt>length</dt>
  <dd>entte Content-Length, par dfaut la taille du fichier</dd>

  <dt>status</dt>
  <dd>code tat  renvoyer. Utile quand un fichier statique sert de page
  derreur.</dd>
</dl>

<p>Si le gestionnaire Rack le supporte, d&#39;autres moyens que le +streaming+ via le
processus Ruby seront utiliss. Si vous utilisez cette mthode, Sinatra grera
automatiquement les requtes de type +range+.</p>

<a name='Accder%20%20l&%2339;objet%20requte'></a>
<h3>Accder  l&#39;objet requte</h3>

<p>L&#39;objet correspondant  la requte envoye peut tre rcupr dans le contexte
de la requte (filtres, routes, gestionnaires d&#39;erreur) au moyen de la mthode
+request+ :</p>

<pre><code class="ruby"># application tournant  l&#39;adresse http://exemple.com/exemple
get &#39;/foo&#39; do
  t = %w[text/css text/html application/javascript]
  request.accept              # [&#39;text/html&#39;, &#39;*/*&#39;]
  request.accept? &#39;text/xml&#39;  # true
  request.preferred_type(t)   # &#39;text/html&#39;
  request.body                # corps de la requte envoye par le client
                              # (voir ci-dessous)
  request.scheme              # &quot;http&quot;
  request.script_name         # &quot;/exemple&quot;
  request.path_info           # &quot;/foo&quot;
  request.port                # 80
  request.request_method      # &quot;GET&quot;
  request.query_string        # &quot;&quot;
  request.content_length      # taille de request.body
  request.media_type          # type de mdia pour request.body
  request.host                # &quot;exemple.com&quot;
  request.get?                # true (mthodes similaires pour les autres
                              # verbes HTTP)
  request.form_data?          # false
  request[&quot;UN_ENTETE&quot;]        # valeur de l&#39;entte UN_ENTETE
  request.referer             # rfrant du client ou &#39;/&#39;
  request.user_agent          # user agent (utilis par la condition :agent)
  request.cookies             # tableau contenant les cookies du navigateur
  request.xhr?                # requte AJAX ?
  request.url                 # &quot;http://exemple.com/exemple/foo&quot;
  request.path                # &quot;/exemple/foo&quot;
  request.ip                  # adresse IP du client
  request.secure?             # false
  request.forwarded?          # vrai (si on est derrire un proxy inverse)
  request.env                 # tableau brut de l&#39;environnement fourni par
                              # Rack
end
</code></pre>

<p>Certaines options, telles que <code>script_name</code> ou <code>path_info</code>
peuvent galement tre modifies :</p>

<pre><code class="ruby">before { request.path_info = &quot;/&quot; }

get &quot;/&quot; do
  &quot;toutes les requtes arrivent ici&quot;
end
</code></pre>

<p><code>request.body</code> est un objet IO ou StringIO :</p>

<pre><code class="ruby">post &quot;/api&quot; do
  request.body.rewind  # au cas o il a dj t lu
  donnees = JSON.parse request.body.read
  &quot;Bonjour #{donnees[&#39;nom&#39;]} !&quot;
end
</code></pre>

<a name='Fichiers%20joints'></a>
<h3>Fichiers joints</h3>

<p>Vous pouvez utiliser la mthode +attachment+ pour indiquer au navigateur que
la rponse devrait tre stocke sur le disque plutt qu&#39;affiche :</p>

<pre><code class="ruby">get &#39;/&#39; do
  attachment
  &quot;enregistre-le !&quot;
end
</code></pre>

<p>Vous pouvez galement lui passer un nom de fichier :</p>

<pre><code class="ruby">get &#39;/&#39; do
  attachment &quot;info.txt&quot;
  &quot;enregistre-le !&quot;
end
</code></pre>

<a name='Grer%20Date%20et%20Time'></a>
<h3>Grer Date et Time</h3>

<p>Sinatra fourni un helper +time_for+ pour convertir une valeur donne en
objet <code>Time</code>. Il peut aussi faire la conversion  partir d&#39;objets +DateTime+,
<code>Date</code> ou de classes similaires :</p>

<pre><code class="ruby">get &#39;/&#39; do
  pass if Time.now &gt; time_for(&#39;Dec 23, 2012&#39;)
  &quot;encore temps&quot;
end
</code></pre>

<p>Cette mthode est utilise en interne par +expires+, +last<em>modified+ et
consorts. Par consquent, vous pouvez trs facilement tendre le
fonctionnement de ces mthodes en surchargeant le helper +time</em>for+ dans
votre application :</p>

<pre><code class="ruby">helpers do
  def time_for(value)
    case value
    when :yesterday then Time.now - 24*60*60
    when :tomorrow  then Time.now + 24*60*60
    else super
    end
  end
end

get &#39;/&#39; do
  last_modified :yesterday
  expires :tomorrow
  &quot;salut&quot;
end
</code></pre>

<a name='Chercher%20les%20fichiers%20de%20templates'></a>
<h3>Chercher les fichiers de templates</h3>

<p>La mthode <code>find_template</code> est utilise pour trouver les fichiers de
templates  gnrer :</p>

<pre><code class="ruby">find_template settings.views, &#39;foo&#39;, Tilt[:haml] do |file|
  puts &quot;pourrait tre #{file}&quot;
end
</code></pre>

<p>Ce n&#39;est pas trs utilise. En revanche, il est utile de pouvoir surcharger
cette mthode afin de dfinir son propre mcanisme de recherche. Par exemple,
vous pouvez utiliser plus d&#39;un rpertoire de vues :</p>

<pre><code class="ruby">set :views, [&#39;views&#39;, &#39;templates&#39;]

helpers do
  def find_template(views, name, engine, &amp;block)
    Array(views).each { |v| super(v, name, engine, &amp;block) }
  end
end
</code></pre>

<p>Un autre exemple est d&#39;utiliser des rpertoires diffrents pour des moteurs
de rendu diffrents :</p>

<pre><code class="ruby">set :views, :sass =&gt; &#39;views/sass&#39;, :haml =&gt; &#39;templates&#39;, :default =&gt; &#39;views&#39;

helpers do
  def find_template(views, name, engine, &amp;block)
    _, folder = views.detect { |k,v| engine == Tilt[k] }
    folder ||= views[:default]
    super(folder, name, engine, &amp;block)
  end
end
</code></pre>

<p>Vous pouvez galement crire cela dans une extension et la partager avec
d&#39;autres !</p>

<p>Notez que <code>find_template</code> ne vrifie pas que le fichier existe mais
va plutt excuter le bloc pour tous les chemins possibles. Cela n&#39;induit pas
un problme de performance dans le sens o <code>render</code> va utiliser +break+ ds
qu&#39;un fichier est trouv. De plus, l&#39;emplacement des templates (et leur
contenu) est mis en cache si vous n&#39;tes pas en mode dveloppement. Vous
devriez garder cela en tte si vous crivez une mthode vraiment dingue.</p>

<a name='Configuration'></a>
<h2>Configuration</h2>

<p>Lanc une seule fois au dmarrage de tous les environnements :</p>

<pre><code class="ruby">configure do
  # dfinir un paramtre
  set :option, &#39;value&#39;

  # dfinir plusieurs paramtre
  set :a =&gt; 1, :b =&gt; 2

  # identique  &quot;set :option, true&quot;
  enable :option

  # identique  &quot;set :option, false&quot;&quot;
  disable :option

  # vous pouvez galement avoir des paramtres dynamiques avec des blocs
  set(:css_dir) { File.join(views, &#39;css&#39;) }
end
</code></pre>

<p>Lanc si l&#39;environnement (variable d&#39;environnement RACK_ENV) est dfini comme
<code>:production</code> :</p>

<p>configure :production do
    ...
  end</p>

<p>Lanc si l&#39;environnement est <code>:production</code> ou
<code>:test</code> :</p>

<p>configure :production, :test do
    ...
  end</p>

<p>Vous pouvez accder  ces paramtres via <code>settings</code> :</p>

<pre><code>configure do
  set :foo, &#39;bar&#39;
end

get &#39;/&#39; do
  settings.foo? # =&gt; true
  settings.foo  # =&gt; &#39;bar&#39;
  ...
end
</code></pre>

<a name='Se%20protger%20des%20attaques'></a>
<h3>Se protger des attaques</h3>

<p>Sinatra utilise <a href="https://github.com/rkh/rack-protection#readme">Rack::Protection</a>
pour protger votre application contre les principales attaques opportunistes.
Vous pouvez trs simplement dsactiver cette fonctionnalit (ce qui exposera
votre application  beaucoup de vulnerabilits courantes) :</p>

<pre><code class="ruby">disable :protection
</code></pre>

<p>Pour dsactiver seulement un type de protection, vous pouvez dfinir <code>protection</code>
avec un hash d&#39;options :</p>

<pre><code class="ruby">set :protection, :except =&gt; :path_traversal
</code></pre>

<p>Vous pouvez galement lui passer un tableau pour dsactiver plusieurs types de
protection :</p>

<pre><code class="ruby">set :protection, :except =&gt; [:path_traversal, :session_hijacking]
</code></pre>

<a name='Paramtres%20disponibles'></a>
<h3>Paramtres disponibles</h3>

<dl>
  <dt>absolute_redirects</dt>
  <dd>Si dsactiv, Sinatra permettra les redirections relatives. Toutefois,
  Sinatra ne sera plus conforme  la RFC 2616 (HTTP 1.1), qui nautorise
  que les redirections absolues.</p>

  Activez si votre application tourne derrire un proxy inverse qui na
  pas t correctement configur. Notez que la mthode <tt>url</tt>
  continuera de produire des URLs absolues, sauf si vous lui passez
  <tt>false</tt> comme second argument.</p>

  <p>Dsactiv par dfaut.</p></dd>

  <dt>add_charsets</dt>
  <dd><p>types mime pour lesquels la mthode <tt>content_type</tt> va
  automatiquement ajouter linformation du <tt>charset</tt>.</p>

  <p>Vous devriez lui ajouter des valeurs plutt que de lcraser :</p>

  <pre>settings.add_charsets >> "application/foobar"</pre></dd>

  <dt>app_file</dt>
  <dd><p>chemin pour le fichier de lapplication principale, utilis pour
  dtecter la racine du projet, les dossiers public et vues, et les
  templates en ligne.</p></dd>

  <dt>bind</dt>
  <dd>adresse IP sur laquelle se brancher (par dfaut : 0.0.0.0). Utiliser
  seulement pour le serveur intgr.</dd>

  <dt>default_encoding</dt>
  <dd>encodage  utiliser si inconnu (par dfaut <tt>"utf-8"</tt>)</dd>

  <dt>dump_errors</dt>
  <dd>afficher les erreurs dans le <tt>log</tt>.
  </dd>

  <dt>environment</dt>
  <dd>environnement courant, par dfaut <tt>ENV['RACK_ENV']</tt>, ou
  <tt>"development"</tt> si absent.</dd>

  <dt>logging</dt>
  <dd>utiliser le <tt>logger</tt>.</dd>

  <dt>lock</dt>
  <dd><p>Place un <tt>lock</tt> autour de chaque requte, nexcutant donc
  quune seule requte par processus Ruby.</p>

  <p>Activ si votre application nest pas <tt>thread-safe</tt>. Dsactiv
  par dfaut.</p></dd>

  <dt>method_override</dt>
  <dd>utilise la magie de <tt>_method</tt> afin de permettre des formulaires
  put/delete dans des navigateurs qui ne le permettent pas.

  </dd>
  <dt>port</dt>
  <dd>port  couter. Utiliser seulement pour le serveur intgr.</dd>

  <dt>prefixed_redirects</dt>
  <dd>si oui ou non <tt>request.script_name</tt> doit tre insr dans les
  redirections si un chemin non absolu est utilis. Ainsi, <tt>redirect
  '/foo'</tt> se comportera comme <tt>redirect to('/foo')</tt>. Dsactiv
  par dfaut.</dd>

  <dt>protection</dt>
  <dd>dfini sil faut activer ou non la protection contre les attaques web.
  Voir la section protection prcdente.</dd>

  <dt>public_dir</dt>
  <dd>alias pour <tt>public_folder</tt>. Voir ci-dessous.</dd>

  <dt>public_folder</dt>
  <dd>chemin pour le dossier  partir duquel les fichiers publics sont servis.
  Utilis seulement si les fichiers statiques doivent tre servis (voir le
  paramtre <tt>static</tt>). Si non dfini, il dcoule du paramtre
  <tt>app_file</tt>.</dd>

  <dt>reload_templates</dt>
  <dd>si oui ou non les templates doivent tre rechargs entre les requtes.
  Activ en mode dveloppement.</dd>

  <dt>root</dt>
  <dd>chemin pour le dossier racine du projet. Si non dfini, il dcoule du
  paramtre <tt>app_file</tt>.</dd>

  <dt>raise_errors</dt>
  <dd>soulever les erreurs (ce qui arrtera lapplication). Dsactiv par
  dfaut sauf lorsque <tt>environment</tt> est dfini 
  <tt>"test"</tt>.</dd>

  <dt>run</dt>
  <dd>si activ, Sinatra soccupera de dmarrer le serveur, ne pas activer si
  vous utiliser rackup ou autres.</dd>

  <dt>running</dt>
  <dd>est-ce que le serveur intgr est en marche ? ne changez pas ce
  paramtre !</dd>

  <dt>server</dt>
  <dd>serveur ou liste de serveurs  utiliser pour le serveur intgr. Par
  dfaut [thin, mongrel, webrick], lordre indiquant la
  priorit.</dd>

  <dt>sessions</dt>
  <dd>active le support des sessions bases sur les cookies, en utilisant
  <tt>Rack::Session::Cookie</tt>. Reportez-vous  la section Utiliser les
  sessions pour plus dinformations.</dd>

  <dt>show_exceptions</dt>
  <dd>affiche la trace de lerreur dans le navigateur lorsquune exception se
  produit. Dsactiv par dfaut sauf lorsque <tt>environment</tt> est
  dfini  <tt>"development"</tt>.</dd>

  <dt>static</dt>
  <dd>Si oui ou non Sinatra doit soccuper de servir les fichiers statiques.
  Dsactivez si vous utilisez un serveur capable de le grer lui mme. Le
  dsactiver augmentera la performance. Activ par dfaut pour le style
  classique, dsactiv pour le style modulaire.</dd>

  <dt>static_cache_control</dt>
  <dd>A dfinir quand Sinatra rend des fichiers statiques pour ajouter les
  en-ttes <tt>Cache-Control</tt>. Utilise le helper <tt>cache_control</tt>.
  Dsactiv par dfaut. Utiliser un array explicite pour dfinir des
  plusieurs valeurs : <tt>set :static_cache_control, [:public, :max_age =>
  300]</tt></dd>

  <dt>threaded</dt>
  <dd> dfinir  <tt>true</tt> pour indiquer  Thin dutiliser
  <tt>EventMachine.defer</tt> pour traiter la requte.</dd>

  <dt>views</dt>
  <dd>chemin pour le dossier des vues. Si non dfini, il dcoule du paramtre
  <tt>app_file</tt>.</dd>
</dl>

<a name='Environements'></a>
<h2>Environements</h2>

<p>Il existe trois environnements prdfinis : <code>&quot;development&quot;</code>,
<code>&quot;production&quot;</code> et <code>&quot;test&quot;</code>. Les environements peuvent tre
slectionn via la variable d&#39;environnement +RACK_ENV+. Sa valeur par dfaut
est <code>&quot;development&quot;</code>. Dans ce mode, tous les templates sont rechargs 
chaque requte. Des handlers spcifiques pour <code>not_found</code> et
<code>error</code> sont installs pour vous permettre d&#39;avoir une pile de trace
dans votre navigateur. En mode <code>&quot;production&quot;</code> et <code>&quot;test&quot;</code> les
templates sont mis en cache par dfaut.</p>

<p>Pour excuter votre application dans un environnement diffrent, utilisez
l&#39;option <code>-e</code> de Ruby :</p>

<pre><code class="bash">$ ruby mon_application.rb -e [ENVIRONMENT]
</code></pre>

<p>Vous pouvez utiliser une des mthodes +development?+, +test?+ et +production?+
pour dterminer quel est l&#39;environnement en cours.</p>

<a name='Grer%20les%20erreurs'></a>
<h2>Grer les erreurs</h2>

<p>Les gestionnaires d&#39;erreur s&#39;excutent dans le mme contexte que les routes ou
les filtres, ce qui veut dire que vous avez accs (entre autres) aux bons
vieux <code>haml</code>, <code>erb</code>, <code>halt</code>, etc.</p>

<a name='NotFound'></a>
<h3>NotFound</h3>

<p>Quand une exception <tt>Sinatra::NotFound</tt> est souleve, ou que le code
retour est 404, le gestionnaire <tt>not_found</tt> est invoqu :</p>

<pre><code class="ruby">not_found do
  &#39;Pas moyen de trouver ce que vous cherchez&#39;
end
</code></pre>

<a name='Error'></a>
<h3>Error</h3>

<p>Le gestionnaire +error+ est invoqu  chaque fois qu&#39;une exception est
souleve dans une route ou un filtre. L&#39;objet exception est accessible via la
variable Rack <code>sinatra.error</code> :</p>

<pre><code class="ruby">error do
  &#39;Dsol mais une mchante erreur est survenue - &#39; + env[&#39;sinatra.error&#39;].name
end
</code></pre>

<p>Erreur sur mesure :</p>

<pre><code class="ruby">error MonErreurSurMesure do
  &#39;Donc il est arriv ceci...&#39; + env[&#39;sinatra.error&#39;].message
end
</code></pre>

<p>Donc si ceci arrive :</p>

<pre><code class="ruby">get &#39;/&#39; do
  raise MonErreurSurMesure, &#39;quelque chose de mal&#39;
end
</code></pre>

<p>Vous obtenez a :</p>

<p>Donc il est arriv ceci... quelque chose de mal</p>

<p>Alternativement, vous pouvez avoir un gestionnaire d&#39;erreur associ  un code
particulier :</p>

<pre><code class="ruby">error 403 do
  &#39;Accs interdit&#39;
end

get &#39;/secret&#39; do
  403
end
</code></pre>

<p>Ou un intervalle :</p>

<pre><code class="ruby">error 400..510 do
  &#39;Boom&#39;
end
</code></pre>

<p>Sinatra installe pour vous quelques gestionnaires <code>not_found</code> et
<code>error</code> gnriques lorsque vous tes en environnement
<code>development</code>.</p>

<a name='Les%20Middlewares%20Rack'></a>
<h2>Les Middlewares Rack</h2>

<p>Sinatra tourne avec <a href="http://rack.rubyforge.org/">Rack</a>, une interface standard
et minimale pour les web frameworks Ruby. Un des points forts de Rack est le
support de ce que l&#39;on appelle des &quot;middlewares&quot; -- composant qui vient se
situer entre le serveur et votre application, et dont le but est de
visualiser/manipuler la requte/rponse HTTP, et d&#39;offrir diverses
fonctionnalits classiques.</p>

<p>Sinatra permet de construire facilement des middlewares Rack via la mthode de
haut niveau +use+ :</p>

<pre><code class="ruby">require &#39;sinatra&#39;
require &#39;mon_middleware_perso&#39;

use Rack::Lint
use MonMiddlewarePerso

get &#39;/bonjour&#39; do
  &#39;Bonjour le monde&#39;
end
</code></pre>

<p>La smantique de +use+ est identique  celle dfinie dans le DSL de
<a href="http://rack.rubyforge.org/doc/classes/Rack/Builder.html">Rack::Builder</a>
(le plus souvent utilis dans un fichier rackup). Par exemple, la mthode
+use+ accepte divers arguments ainsi que des blocs :</p>

<pre><code>use Rack::Auth::Basic do |login, password|
  login == &#39;admin&#39; &amp;&amp; password == &#39;secret&#39;
end
</code></pre>

<p>Rack est distribu avec une bonne varit de middlewares standards pour les
logs, dbuguer, faire du routage URL, de l&#39;authentification, grer des
sessions. Sinatra utilise beaucoup de ces composants automatiquement via la
configuration, donc pour ceux-ci vous n&#39;aurez pas  utiliser la mthode <code>use</code>.</p>

<a name='Tester'></a>
<h2>Tester</h2>

<p>Les tests pour Sinatra peuvent tre crit avec n&#39;importe quelle bibliothque
base sur Rack. <a href="http://gitrdoc.com/brynary/rack-test">Rack::Test</a> est
recommand :</p>

<pre><code class="ruby">require &#39;mon_application_sinatra&#39;
require &#39;test/unit&#39;
require &#39;rack/test&#39;

class MonTest &lt; Test::Unit::TestCase
  include Rack::Test::Methods

  def app
    Sinatra::Application
  end

  def test_ma_racine
    get &#39;/&#39;
    assert_equal &#39;Bonjour le monde !&#39;, last_response.body
  end

  def test_avec_des_parametres
    get &#39;/rencontrer&#39;, :name =&gt; &#39;Frank&#39;
    assert_equal &#39;Salut Frank !&#39;, last_response.body
  end

  def test_avec_rack_env
    get &#39;/&#39;, {}, &#39;HTTP_USER_AGENT&#39; =&gt; &#39;Songbird&#39;
    assert_equal &quot;Vous utilisez Songbird !&quot;, last_response.body
  end
end
</code></pre>

<a name='Sinatra::Base%20-%20Les%20Middlewares,%20Bibliothques,%20et%20Applications%20Modulaires'></a>
<h2>Sinatra::Base - Les Middlewares, Bibliothques, et Applications Modulaires</h2>

<p>Dfinir votre application au niveau suprieur fonctionne bien dans le cas des
micro-applications mais prsente pas mal d&#39;inconvnients pour crer des
composants rutilisables sous forme de middlewares Rack, de Rails metal, de
simples librairies avec un composant serveur ou mme d&#39;extensions Sinatra. Le
niveau suprieur suppose une configuration dans le style des micro-applications
(une application d&#39;un seul fichier, des rpertoires <code>./public</code> et
<code>./views</code>, des logs, une page d&#39;erreur, etc...). C&#39;est l que
<code>Sinatra::Base</code> prend tout son intrt :</p>

<pre><code class="ruby">require &#39;sinatra/base&#39;

class MonApplication &lt; Sinatra::Base
  set :sessions, true
  set :foo, &#39;bar&#39;

  get &#39;/&#39; do
    &#39;Bonjour le monde !&#39;
  end
end
</code></pre>

<p>Les mthodes de la classe <code>Sinatra::Base</code> sont parfaitement identiques 
celles disponibles via le DSL de haut niveau. Il suffit de deux modifications
pour transformer la plupart des applications de haut niveau en un composant
<code>Sinatra::Base</code> :</p>

<ul>
<li>Votre fichier doit charger <code>sinatra/base</code> au lieu de <code>sinatra</code>, sinon toutes
les mthodes du DSL Sinatra seront importes dans l&#39;espace de nom principal.</li>
<li>Les gestionnaires de routes, la gestion d&#39;erreur, les filtres et les options
doivent tre placs dans une classe hritant de <code>Sinatra::Base</code>.</li>
</ul>

<p><code>Sinatra::Base</code> est une page blanche. La plupart des options sont
dsactives par dfaut, y compris le serveur intgr. Reportez-vous 
<a href="http://sinatra.github.com/configuration.html">Options et Configuration</a>
pour plus d&#39;informations sur les options et leur fonctionnement.</p>

<a name='Style%20modulaire%20vs.%20style%20classique'></a>
<h3>Style modulaire vs. style classique</h3>

<p>Contrairement aux ides reues, il n&#39;y a rien de mal  utiliser le style
classique. Si c&#39;est ce qui convient pour votre application, vous n&#39;avez pas
aucune raison de passer  une application modulaire.</p>

<p>Le principal inconvnient du style classique sur le style modulaire est que vous
ne pouvez avoir qu&#39;une application Ruby par processus Ruby. Si vous pensez en
utiliser plus, passez au style modulaire. Et rien ne vous empche de mixer style
classique et style modulaire.</p>

<p>Si vous passez d&#39;un style  l&#39;autre, souvenez-vous des quelques diffrences
mineures en ce qui concerne les paramtres par dfaut :</p>

<p>Paramtre         Classique                   Modulaire</p>

<p>app<em>file          fichier chargeant sinatra   fichier hritant de Sinatra::Base
  run               $0 == app</em>file              false
  logging           true                        false
  method<em>override   true                        false
  inline</em>templates  true                        false
  static            true                        false</p>

<a name='Servir%20une%20application%20modulaire'></a>
<h3>Servir une application modulaire</h3>

<p>Il y a deux faons de faire pour dmarrer une application modulaire, dmarrez
avec <code>run!</code> :</p>

<pre><code class="ruby"># my_app.rb
require &#39;sinatra/base&#39;

class MyApp &lt; Sinatra::Base
  # ... code de l&#39;application ici ...

  # dmarre le serveur si ce fichier est directement excut
  run! if app_file == $0
end
</code></pre>

<p>Dmarrez ensuite avec :</p>

<pre><code class="bash">$ ruby my_app.rb
</code></pre>

<p>Ou alors avec un fichier <code>config.ru</code>, qui permet d&#39;utiliser n&#39;importe
quel gestionnaire Rack :</p>

<pre><code class="ruby"># config.ru
require &#39;./my_app&#39;
run MyApp
</code></pre>

<p>Excutez :</p>

<pre><code class="bash">$ rackup -p 4567
</code></pre>

<a name='Utiliser%20une%20application%20de%20style%20classique%20avec%20un%20fichier%20config.ru'></a>
<h3>Utiliser une application de style classique avec un fichier config.ru</h3>

<p>Ecrivez votre application :</p>

<pre><code class="ruby"># app.rb
require &#39;sinatra&#39;

get &#39;/&#39; do
  &#39;Bonjour le monde !&#39;
end
</code></pre>

<p>Et un fichier <code>config.ru</code> correspondant :</p>

<pre><code class="ruby">require &#39;./app&#39;
run Sinatra::Application
</code></pre>

<a name='Quand%20utiliser%20un%20fichier%20config.ru%20?'></a>
<h3>Quand utiliser un fichier config.ru ?</h3>

<p>Quelques cas o vous devriez utiliser un fichier <code>config.ru</code> :</p>

<ul>
<li>Vous souhaitez dployer avec un autre gestionnaire Rack (Passenger, Unicorn,
Heroku, ...).</li>
<li>Vous souhaitez utiliser plus d&#39;une sous-classe de <code>Sinatra::Base</code>.</li>
<li>Vous voulez utiliser Sinatra comme un middleware, non en tant que
endpoint.</li>
</ul>

<p><strong>Il n&#39;est pas ncessaire de passer par un fichier <code>config.ru</code> pour la
seule raison que vous tes pass au style modulaire, et vous n&#39;avez pas besoin
de passer au style modulaire pour utiliser un fichier <code>config.ru</code>.</strong></p>

<a name='Utiliser%20Sinatra%20comme%20Middleware'></a>
<h3>Utiliser Sinatra comme Middleware</h3>

<p>Non seulement Sinatra peut utiliser d&#39;autres middlewares Rack, il peut
galement tre  son tour utilis au-dessus de n&#39;importe quel endpoint Rack
en tant que middleware. Ce endpoint peut trs bien tre une autre
application Sinatra, ou n&#39;importe quelle application base sur Rack
(Rails/Ramaze/Camping/...) :</p>

<pre><code class="ruby">require &#39;sinatra/base&#39;

class EcranDeConnexion &lt; Sinatra::Base
  enable :sessions

  get(&#39;/connexion&#39;) { haml :connexion }

  post(&#39;/connexion&#39;) do
    if params[:nom] = &#39;admin&#39; &amp;&amp; params[:motdepasse] = &#39;admin&#39;
      session[&#39;nom_utilisateur&#39;] = params[:nom]
    else
      redirect &#39;/connexion&#39;
    end
  end
end

class MonApp &lt; Sinatra::Base
  # le middleware sera appel avant les filtres
  use EcranDeConnexion

  before do
    unless session[&#39;nom_utilisateur&#39;]
      halt &quot;Accs refus, merci de vous &lt;a href=&#39;/connexion&#39;&gt;connecter&lt;/a&gt;.&quot;
    end
  end

  get(&#39;/&#39;) { &quot;Bonjour #{session[&#39;nom_utilisateur&#39;]}.&quot; }
end
</code></pre>

<a name='Cration%20dynamique%20d&%2339;applications'></a>
<h3>Cration dynamique d&#39;applications</h3>

<p>Il se peut que vous ayez besoin de crer une nouvelle application  l&#39;excution
sans avoir  les assigner  une constante, vous pouvez le faire grce 
<code>Sinatra.new</code> :</p>

<pre><code class="ruby">require &#39;sinatra/base&#39;
mon_app = Sinatra.new { get(&#39;/&#39;) { &quot;salut&quot; } }
mon_app.run!
</code></pre>

<p>L&#39;application dont elle hrite peut tre pass en argument optionnel :</p>

<pre><code class="ruby"># config.ru
require &#39;sinatra/base&#39;

controleur = Sinatra.new do
  enable :logging
  helpers MyHelpers
end

map(&#39;/a&#39;) do
  run Sinatra.new(controleur) { get(&#39;/&#39;) { &#39;a&#39; } }
end

map(&#39;/b&#39;) do
  run Sinatra.new(controleur) { get(&#39;/&#39;) { &#39;b&#39; } }
end
</code></pre>

<p>C&#39;est notamment utile pour tester des extensions  Sinatra ou bien pour
utiliser Sinatra dans votre propre bibliothque.</p>

<p>Cela permet galement d&#39;utiliser trs facilement Sinatra comme middleware :</p>

<pre><code class="ruby">require &#39;sinatra/base&#39;

use Sinatra do
  get(&#39;/&#39;) { ... }
end

run RailsProject::Application
</code></pre>

<a name='Contextes%20et%20Binding'></a>
<h2>Contextes et Binding</h2>

<p>Le contexte dans lequel vous tes dtermine les mthodes et variables
disponibles.</p>

<a name='Contexte%20de%20l&%2339;application/classe'></a>
<h3>Contexte de l&#39;application/classe</h3>

<p>Toute application Sinatra correspond  une sous-classe de <code>Sinatra::Base</code>.
Si vous utilisez le DSL haut niveau (<code>require &#39;sinatra&#39;</code>), alors cette
classe est <code>Sinatra::Application</code>, sinon il s&#39;agit de la sous-classe que
vous avez dfinie. Dans le contexte de la classe, vous avez accs aux mthodes
telles que <code>get</code> ou <code>before</code>, mais vous n&#39;avez pas accs aux objets +request+
ou +session+ car c&#39;est la mme classe d&#39;application qui traitera toutes les
requtes.</p>

<p>Les options dfinies au moyen de +set+ deviennent des mthodes de classe :</p>

<pre><code class="ruby">class MonApp &lt; Sinatra::Base
  # Eh, je suis dans le contexte de l&#39;application !
  set :foo, 42
  foo # =&gt; 42

  get &#39;/foo&#39; do
    # Eh, je ne suis plus dans le contexte de l&#39;application !
  end
end
</code></pre>

<p>Vous avez le binding du contexte de l&#39;application dans :</p>

<ul>
<li>Le corps de la classe d&#39;application</li>
<li>Les mthodes dfinies par les extensions</li>
<li>Le bloc pass  <code>helpers</code></li>
<li>Les procs/blocs utiliss comme argument pour <code>set</code></li>
<li>Le bloc pass  <code>Sinatra.new</code></li>
</ul>

<p>Vous pouvez atteindre ce contexte (donc la classe) de la faon suivante :</p>

<ul>
<li>Via l&#39;objet pass dans les blocs <code>configure</code> (<code>configure { |c| ... }</code>)</li>
<li>En utilisant <code>settings</code> dans le contexte de la requte</li>
</ul>

<a name='Contexte%20de%20la%20requte/instance'></a>
<h3>Contexte de la requte/instance</h3>

<p>Pour tout traitement d&#39;une requte, une nouvelle instance de votre classe
d&#39;application est cre et tous vos gestionnaires sont excuts dans ce
contexte. Dans ce dernier, vous pouvez accder aux objets <code>request</code> et
<code>session</code> et faire appel aux fonctions de rendu telles que <code>erb</code> ou <code>haml</code>.
Vous pouvez accder au contexte de l&#39;application depuis le contexte de la
requte au moyen de <code>settings</code> :</p>

<pre><code class="ruby">class MonApp &lt; Sinatra::Base
  # Eh, je suis dans le contexte de l&#39;application !
  get &#39;/ajouter_route/:nom&#39; do
    # Contexte de la requte pour &#39;/ajouter_route/:nom&#39;
    @value = 42

    settings.get(&quot;/#{params[:nom]}&quot;) do
      # Contexte de la requte pour &quot;/#{params[:nom]}&quot;
      @value # =&gt; nil (on est pas au sein de la mme requte)
    end

    &quot;Route ajoute !&quot;
  end
end
</code></pre>

<p>Vous avez le binding du contexte de la requte dans :</p>

<ul>
<li>les blocs get/head/post/put/delete/options</li>
<li>les filtres before/after</li>
<li>les mthodes utilitaires (dfinies au moyen de <code>helpers</code>)</li>
<li>les vues/templates</li>
</ul>

<a name='Le%20contexte%20de%20dlgation'></a>
<h3>Le contexte de dlgation</h3>

<p>Le contexte de dlgation se contente de transmettre les appels de mthodes au
contexte de classe. Toutefois, il ne se comporte pas  100% comme le contexte
de classe car vous n&#39;avez pas le binding de la classe : seules les mthodes
spcifiquement dclares pour dlgation sont disponibles et il n&#39;est pas
possible de partager des variables/tats avec le contexte de classe
(comprenez : <code>self</code> n&#39;est pas le mme). Vous pouvez ajouter des dlgation de
mthodes en appelant <code>Sinatra::Delegator.delegate :method_name</code>.</p>

<p>Vous avez le binding du contexte de dlgation dans :</p>

<ul>
<li>Le binding de haut niveau, si vous avez utilis <code>require &quot;sinatra&quot;</code></li>
<li>Un objet qui inclut le module <code>Sinatra::Delegator</code></li>
</ul>

<p>Jetez un oeil pour vous faire une ide : voici le
<a href="https://github.com/sinatra/sinatra/blob/ca06364/lib/sinatra/base.rb#L1609-1633">mixin Sinatra::Delegator</a>
qui <a href="https://github.com/sinatra/sinatra/blob/ca06364/lib/sinatra/main.rb#L28-30">tend l&#39;objet principal</a>.</p>

<a name='Ligne%20de%20commande'></a>
<h2>Ligne de commande</h2>

<p>Les applications Sinatra peuvent tre lances directement :</p>

<pre><code class="ruby">$ ruby mon_application.rb [-h] [-x] [-e ENVIRONNEMENT] [-p PORT] [-o HOTE] [-s SERVEUR]
</code></pre>

<p>Les options sont :</p>

<pre><code>-h # aide
-p # dclare le port (4567 par dfaut)
-o # dclare l&#39;hte (0.0.0.0 par dfaut)
-e # dclare l&#39;environnement (+development+ par dfaut)
-s # dclare le serveur/gestionnaire  utiliser (thin par dfaut)
-x # active le mutex lock (off par dfaut)
</code></pre>

<a name='Configuration%20ncessaire'></a>
<h2>Configuration ncessaire</h2>

<p>Les versions suivantes de Ruby sont officiellement supportes :</p>

<dl>
  <dt>Ruby 1.8.7</dt>
  <dd>1.8.7 est compltement support, toutefois si rien ne vous en empche,
  nous vous recommandons de passer  1.9.2 ou bien de passer  JRuby ou
  Rubinius. Le support de Ruby 1.8.7 ne sera pas supprim avant la sortie de
  Sinatra 2.0 et de Ruby 2.0,  moins quun improbable Ruby 1.8.8
  apparaisse. Et mme dans ce cas, nous pourrions continuer  le supporter.
  **Ruby 1.8.6 nest plus support**. Si vous souhaitez utiliser la
  version 1.8.6, vous devez revenir  Sinatra 1.2 qui continuera  recevoir
  des corrections de bugs tant que Sinatra 1.4.0 ne sera pas livr.</dd>

  <dt>Ruby 1.9.2</dt>
  <dd>1.9.2 est totalement support et recommand. Nutilisez pas 1.9.2p0 car
  il provoque des erreurs de segmentation  lexcution de Sinatra. Son
  support continuera au minimum jusqu la sortie de Ruby 1.9.4/2.0 et le
  support de la dernire version 1.9 se poursuivra aussi longtemps que la
  core team de Ruby la supportera.</dd>

  <dt>Ruby 1.9.3</dt>
  <dd>1.9.3 est totalement support et recommand. Nous vous rappelons que
  passer  1.9.3 depuis une version prcdente annulera toutes les
  sessions.</dd>


  <dt>Rubinius</dt>
  <dd>Rubinius est officiellement support (Rubinius <= 1.2.4), tout
  fonctionne, y compris tous les langages de template. La version 2.0 
  venir est galement supporte.</dd>

  <dt>JRuby</dt>
  <dd>JRuby est officiellement support (JRuby <= 1.6.5). Aucune anomalie
  avec des bibliothques de templates tierces ne sont connues. Toutefois, si
  vous choisissez JRuby, alors tournez vous vers des gestionnaires Rack JRuby
  car le serveur Thin nest pas compltement support par JRuby. Le
  support des extensions C dans JRuby est encore exprimental, ce qui
  naffecte que RDiscount, Redcarpet and RedCloth pour linstant.</dd>
</dl>

<p>Nous gardons galement un oeil sur les versions Ruby  venir.</p>

<p>Les implmentations Ruby suivantes ne sont pas officiellement supportes mais
sont malgr tout connues pour permettre de faire fonctionner Sinatra :</p>

<ul>
<li>Versions plus anciennes de JRuby et Rubinius</li>
<li>Ruby Enterprise Edition</li>
<li>MacRuby, Maglev, IronRuby</li>
<li>Ruby 1.9.0 et 1.9.1 (mais nous dconseillons leur utilisation)</li>
</ul>

<p>Le fait de ne pas tre officiellement support signifie que si quelque chose
ne fonctionne pas uniquement sur cette plateforme alors c&#39;est un problme de la
plateforme et pas un bug de Sinatra.</p>

<p>Nous lanons galement notre intgration continue (CI) avec ruby-head (la
future 2.0.0) et la branche 1.9.4, mais tant donn les volutions continuelles,
nous ne pouvont rien garantir, si ce n&#39;est que les versions 1.9.4p0 et 2.0.0p0
seront supportes.</p>

<p>Sinatra devrait fonctionner sur n&#39;importe quel systme d&#39;exploitation
supportant l&#39;implmentation Ruby choisie.</p>

<p>Il n&#39;est pas possible d&#39;utiliser Sinatra sur Cardinal, SmallRuby, Blueuby ou
toute version de Ruby antrieure  1.8.7  l&#39;heure actuelle.</p>

<a name='Essuyer%20les%20pltres'></a>
<h2>Essuyer les pltres</h2>

<p>Si vous voulez utiliser la toute dernire version de Sinatra, n&#39;ayez pas peur
de faire tourner votre application sur la branche master, cela devrait tre
stable.</p>

<p>Nous publions galement une gem de +prerelease+ de temps en temps que vous
pouvez installer comme suit :</p>

<pre><code class="ruby">$ gem install sinatra --pre
</code></pre>

<p>afin d&#39;avoir les toutes dernires fonctionnalits.</p>

<a name='Avec%20Bundler'></a>
<h3>Avec Bundler</h3>

<p>Si vous voulez faire tourner votre application avec le tout dernier
Sinatra, <a href="http://gembundler.com/">Bundler</a> est recommand.</p>

<p>Tout d&#39;abord, installer bundler si vous ne l&#39;avez pas :</p>

<pre><code class="bash">$ gem install bundler
</code></pre>

<p>Ensuite, dans le dossier de votre projet, crez un fichier +Gemfile+ :</p>

<pre><code class="ruby">source :rubygems
gem &#39;sinatra&#39;, :git =&gt; &quot;git://github.com/sinatra/sinatra.git&quot;

# autres dpendances
gem &#39;haml&#39;                    # par exemple, si vous utilisez haml
gem &#39;activerecord&#39;, &#39;~&gt; 3.0&#39;  # peut-tre que vous avez galement besoin
                              # de ActiveRecord 3.x
</code></pre>

<p>Notez que vous aurez  lister toutes les dpendances de votre application dans
ce fichier. Les dpendances directes de Sinatra (Rack et Tilt) seront
automatiquement tlcharges et ajoutes par Bundler.</p>

<p>Maintenant, vous pouvez faire tourner votre application de la faon suivante :</p>

<pre><code class="bash">$ bundle exec ruby myapp.rb
</code></pre>

<a name='Faites%20le%20vous-mme'></a>
<h3>Faites le vous-mme</h3>

<p>Crez un clone local et dmarrez votre application avec le dossier
<code>sinatra/lib</code> dans le <code>$LOAD_PATH</code> :</p>

<pre><code class="bash">$ cd myapp
$ git clone git://github.com/sinatra/sinatra.git
$ ruby -Isinatra/lib myapp.rb

A l&#39;avenir, pour mettre  jour le code source de Sinatra :

```bash
$ cd myapp/sinatra
$ git pull
</code></pre>

<a name='Installez%20globalement'></a>
<h3>Installez globalement</h3>

<p>Vous pouvez construire la gem vous-mme :</p>

<pre><code class="bash">$ git clone git://github.com/sinatra/sinatra.git
$ cd sinatra
$ rake sinatra.gemspec
$ rake install
</code></pre>

<p>Si vous installez les gems en tant que +root+, la dernire tape sera :</p>

<pre><code class="bash">$ sudo rake install
</code></pre>

<a name='Versions'></a>
<h2>Versions</h2>

<p>Sinatra se conforme aux (versions smantiques)[http://semver.org/], aussi bien
SemVer que SemVerTag.</p>

<a name='Mais%20encore'></a>
<h2>Mais encore</h2>

<ul>
<li><a href="http://www.sinatrarb.com/">Site internet</a> - Plus de documentation,
de news, et des liens vers d&#39;autres ressources.</li>
<li><a href="http://www.sinatrarb.com/contributing">Contribuer</a> - Vous avez trouv un
bug ? Besoin d&#39;aide ? Vous avez un patch ?</li>
<li><a href="http://github.com/sinatra/sinatra/issues">Suivi des problmes</a></li>
<li><a href="http://twitter.com/sinatra">Twitter</a></li>
<li>[Mailing List])(http://groups.google.com/group/sinatrarb/topics)</li>
<li>[IRC : #sinatra](irc://chat.freenode.net/#sinatra) sur http://freenode.net</li>
<li>[IRC : #sinatra](irc://chat.freenode.net/#sinatra) on http://freenode.net</li>
<li><a href="http://sinatra-book.gittr.com">Sinatra Book</a> Tutoriels et recettes</li>
<li><a href="http://recipes.sinatrarb.com/">Sinatra Recipes</a> trucs et astuces rdigs par 
la communaut</li>
<li>Documentation API de la <a href="http://rubydoc.info/gems/sinatra">dernire version</a>
ou du <a href="http://rubydoc.info/github/sinatra/sinatra">HEAD courant</a> sur
http://rubydoc.info</li>
<li><a href="http://travis-ci.org/sinatra/sinatra">CI server</a></li>
</ul>
