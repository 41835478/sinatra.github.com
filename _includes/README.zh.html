<div class='toc'>
	<ol class='level-1'>
		<li><a href='#%E8%B7%AF%E7%94%B1'>路由</a></li>
		<ol class='level-2'>
			<li><a href='#%E6%9D%A1%E4%BB%B6'>条件</a></li>
			<li><a href='#%E8%BF%94%E5%9B%9E%E5%80%BC'>返回值</a></li>
		</ol>
		<li><a href='#%E9%9D%99%E6%80%81%E6%96%87%E4%BB%B6'>静态文件</a></li>
		<li><a href='#%E8%A7%86%E5%9B%BE%20/%20%E6%A8%A1%E6%9D%BF'>视图 / 模板</a></li>
		<ol class='level-2'>
			<li><a href='#Haml%E6%A8%A1%E6%9D%BF'>Haml模板</a></li>
			<li><a href='#Erb%E6%A8%A1%E6%9D%BF'>Erb模板</a></li>
			<li><a href='#Erubis'>Erubis</a></li>
			<li><a href='#Builder%20%E6%A8%A1%E6%9D%BF'>Builder 模板</a></li>
			<li><a href='#Nokogiri%20%E6%A8%A1%E6%9D%BF'>Nokogiri 模板</a></li>
			<li><a href='#Sass%20%E6%A8%A1%E6%9D%BF'>Sass 模板</a></li>
			<li><a href='#Scss%20%E6%A8%A1%E6%9D%BF'>Scss 模板</a></li>
			<li><a href='#Less%20%E6%A8%A1%E6%9D%BF'>Less 模板</a></li>
			<li><a href='#Liquid%20%E6%A8%A1%E6%9D%BF'>Liquid 模板</a></li>
			<li><a href='#Markdown%20%E6%A8%A1%E6%9D%BF'>Markdown 模板</a></li>
			<li><a href='#Textile%20%E6%A8%A1%E6%9D%BF'>Textile 模板</a></li>
			<li><a href='#RDoc%20%E6%A8%A1%E6%9D%BF'>RDoc 模板</a></li>
			<li><a href='#Radius%20%E6%A8%A1%E6%9D%BF'>Radius 模板</a></li>
			<li><a href='#Markaby%20%E6%A8%A1%E6%9D%BF'>Markaby 模板</a></li>
			<li><a href='#CoffeeScript%20%E6%A8%A1%E6%9D%BF'>CoffeeScript 模板</a></li>
			<li><a href='#%E5%86%85%E8%81%94%E6%A8%A1%E6%9D%BF%E5%AD%97%E7%AC%A6%E4%B8%B2'>内联模板字符串</a></li>
			<li><a href='#%E5%9C%A8%E6%A8%A1%E6%9D%BF%E4%B8%AD%E8%AE%BF%E9%97%AE%E5%8F%98%E9%87%8F'>在模板中访问变量</a></li>
			<li><a href='#%E5%86%85%E8%81%94%E6%A8%A1%E6%9D%BF'>内联模板</a></li>
			<li><a href='#%E5%85%B7%E5%90%8D%E6%A8%A1%E6%9D%BF'>具名模板</a></li>
		</ol>
		<li><a href='#%E8%BE%85%E5%8A%A9%E6%96%B9%E6%B3%95'>辅助方法</a></li>
		<li><a href='#%E8%BF%87%E6%BB%A4%E5%99%A8'>过滤器</a></li>
		<li><a href='#%E6%8C%82%E8%B5%B7'>挂起</a></li>
		<li><a href='#%E8%AE%A9%E8%B7%AF'>让路</a></li>
		<li><a href='#%E8%AE%BF%E9%97%AE%E8%AF%B7%E6%B1%82%E5%AF%B9%E8%B1%A1'>访问请求对象</a></li>
		<li><a href='#%E9%85%8D%E7%BD%AE'>配置</a></li>
		<li><a href='#%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86'>错误处理</a></li>
		<ol class='level-2'>
			<li><a href='#%E6%9C%AA%E6%89%BE%E5%88%B0'>未找到</a></li>
			<li><a href='#%E9%94%99%E8%AF%AF'>错误</a></li>
		</ol>
		<li><a href='#%E5%AA%92%E4%BD%93%E7%B1%BB%E5%9E%8B'>媒体类型</a></li>
		<li><a href='#Rack%20%E4%B8%AD%E9%97%B4%E4%BB%B6'>Rack 中间件</a></li>
		<li><a href='#%E6%B5%8B%E8%AF%95'>测试</a></li>
		<li><a href='#Sinatra::Base%20-%20%E4%B8%AD%E9%97%B4%E4%BB%B6%EF%BC%8C%E7%A8%8B%E5%BA%8F%E5%BA%93%E5%92%8C%E6%A8%A1%E5%9D%97%E5%8C%96%E5%BA%94%E7%94%A8'>Sinatra::Base - 中间件，程序库和模块化应用</a></li>
		<ol class='level-2'>
			<li><a href='#%E6%8A%8ASinatra%E5%BD%93%E6%88%90%E4%B8%AD%E9%97%B4%E4%BB%B6%E6%9D%A5%E4%BD%BF%E7%94%A8'>把Sinatra当成中间件来使用</a></li>
		</ol>
		<li><a href='#%E5%8F%98%E9%87%8F%E5%9F%9F%E5%92%8C%E7%BB%91%E5%AE%9A'>变量域和绑定</a></li>
		<ol class='level-2'>
			<li><a href='#%E5%BA%94%E7%94%A8/%E7%B1%BB%20%E5%8F%98%E9%87%8F%E5%9F%9F'>应用/类 变量域</a></li>
			<li><a href='#%E8%AF%B7%E6%B1%82/%E5%AE%9E%E4%BE%8B%20%E5%8F%98%E9%87%8F%E5%9F%9F'>请求/实例 变量域</a></li>
			<li><a href='#%E4%BB%A3%E7%90%86%E5%8F%98%E9%87%8F%E5%9F%9F'>代理变量域</a></li>
		</ol>
		<li><a href='#%E5%91%BD%E4%BB%A4%E8%A1%8C'>命令行</a></li>
		<li><a href='#%E7%B4%A7%E8%BF%BD%E5%89%8D%E6%B2%BF'>紧追前沿</a></li>
		<li><a href='#%E6%9B%B4%E5%A4%9A'>更多</a></li>
	</ol>
</div>



<p><em>注：本文档仅仅是英文版的翻译，会出现内容没有及时更新的情况发生。如有不一致的地方，请以英文版为准。</em></p>

<p>Sinatra是一个基于Ruby语言，以最小精力为代价快速创建web应用为目的的DSL（领域专属语言）：</p>

<pre># myapp.rb
require 'sinatra'

get '/' do
  'Hello world!'
end</pre>

<p>安装gem然后运行：</p>

<pre>gem install sinatra
ruby rubygems myapp.rb</pre>

<p>在该地址查看： <a href="http://localhost:4567">localhost:4567</a></p>

<a name='%E8%B7%AF%E7%94%B1'></a>
<h2>路由</h2>

<p>在Sinatra中，一个路由是一个HTTP方法与URL匹配范式的配对。
每个路由都与一个代码块关联：</p>

<pre>get '/' do
  .. 显示一些事物 ..
end

post '/' do
  .. 创建一些事物 ..
end

put '/' do
  .. 更新一些事物 ..
end

delete '/' do
  .. 消灭一些事物 ..
end</pre>

<p>路由按照它们被定义的顺序进行匹配。
第一个与请求匹配的路由会被调用。</p>

<p>路由范式可以包括具名参数，
可通过<tt>params</tt>哈希表获得：</p>

<pre>get '/hello/:name' do
  # 匹配 &quot;GET /hello/foo&quot; 和 &quot;GET /hello/bar&quot;
  # params[:name] 的值是 'foo' 或者 'bar'
  &quot;Hello #{params[:name]}!&quot;
end</pre>

<p>你同样可以通过代码块参数获得具名参数：</p>

<pre>get '/hello/:name' do |n|
  &quot;Hello #{n}!&quot;
end</pre>

<p>路由范式也可以包含通配符参数，
可以通过<tt>params[:splat]</tt> 数组获得。</p>

<pre>get '/say/*/to/*' do
  # 匹配 /say/hello/to/world
  params[:splat] # =&gt; [&quot;hello&quot;, &quot;world&quot;]
end

get '/download/*.*' do
  # 匹配 /download/path/to/file.xml
  params[:splat] # =&gt; [&quot;path/to/file&quot;, &quot;xml&quot;]
end</pre>

<p>通过正则表达式匹配的路由：</p>

<pre>get %r{/hello/([\w]+)} do
  &quot;Hello, #{params[:captures].first}!&quot;
end</pre>

<p>或者使用代码块参数：</p>

<pre>get %r{/hello/([\w]+)} do |c|
  &quot;Hello, #{c}!&quot;
end</pre>

<a name='%E6%9D%A1%E4%BB%B6'></a>
<h3>条件</h3>

<p>路由也可以包含多样的匹配条件，比如user agent：</p>

<pre>get '/foo', :agent =&gt; /Songbird (\d\.\d)[\d\/]*?/ do
  &quot;你正在使用Songbird，版本是 #{params[:agent][0]}&quot;
end

get '/foo' do
  # 匹配除Songbird以外的浏览器
end</pre>

<p>其他可选的条件是 <tt>host_name</tt> 和 <tt>provides</tt>：</p>

<pre>get '/', :host_name =&gt; /^admin\./ do
  &quot;管理员区域，无权进入！&quot;
end

get '/', :provides =&gt; 'html' do
  haml :index
end

get '/', :provides =&gt; ['rss', 'atom', 'xml'] do
  builder :feed
end</pre>

<p>你也可以很轻松地定义自己的条件：</p>

<pre>set(:probability) { |value| condition { rand &lt;= value } }

get '/win_a_car', :probability =&gt; 0.1 do
  &quot;You won!&quot;
end

get '/win_a_car' do
  &quot;Sorry, you lost.&quot;
end</pre>

<a name='%E8%BF%94%E5%9B%9E%E5%80%BC'></a>
<h3>返回值</h3>

<p>一个路由代码块的返回值最少决定了返回给HTTP客户端的响应体，
或者至少决定了在Rack堆栈中的下一个中间件。
大多数情况下，将是一个字符串，就像上面的例子中的一样。
但是其他值也是可以接受的。</p>

<p>你可以返回任何对象，或者是一个合理的Rack响应， Rack
body对象或者HTTP状态码：</p>
<ul><li>
<p>一个包含三个元素的数组: <tt>[状态 (Fixnum), 头 (Hash),
响应体 (回应 #each)]</tt></p>
</li><li>
<p>一个包含两个元素的数组: <tt>[状态 (Fixnum), 响应体 (回应
#each)]</tt></p>
</li><li>
<p>一个能够回应 <tt>#each</tt> ，只传回字符串的对象</p>
</li><li>
<p>一个代表状态码的数字</p>
</li></ul>

<p>那样，我们可以轻松的实现例如流式传输的例子：</p>

<pre>class Stream
  def each
    100.times { |i| yield &quot;#{i}\n&quot; }
  end
end

get('/') { Stream.new }</pre>

<a name='%E9%9D%99%E6%80%81%E6%96%87%E4%BB%B6'></a>
<h2>静态文件</h2>

<p>静态文件是从 <tt>./public</tt>
目录提供服务。你可以通过设置<tt>:public</tt>
选项设定一个不同的位置：</p>

<pre>set :public, File.dirname(__FILE__) + '/static'</pre>

<p>请注意public目录名并没有被包含在URL之中。文件
<tt>./public/css/style.css</tt>是通过 <tt><a
href="http://example.com/css/style.css">example.com/css/style.css</a></tt>地址访问。</p>

<a name='%E8%A7%86%E5%9B%BE%20/%20%E6%A8%A1%E6%9D%BF'></a>
<h2>视图 / 模板</h2>

<p>模板被假定直接位于<tt>./views</tt>目录。
要使用不同的视图目录：</p>

<pre>set :views, File.dirname(__FILE__) + '/templates'</pre>

<p>请记住一件非常重要的事情，你只可以使用符号引用模板，
即使它们在子目录下 （在这种情况下，使用
<tt>:'subdir/template'</tt>）。
你必须使用一个符号，因为渲染方法会直接地渲染
任何传入的字符串。</p>

<a name='Haml%E6%A8%A1%E6%9D%BF'></a>
<h3>Haml模板</h3>

<p>需要引入haml gem/library以渲染 HAML 模板：</p>

<pre>## 你需要在你的应用中引入 haml
require 'haml'

get '/' do
  haml :index
end</pre>

<p>渲染 <tt>./views/index.haml</tt>。</p>

<p><a
href="http://haml-lang.com/docs/yardoc/file.HAML_REFERENCE.html#options">Haml的选项</a>
可以通过Sinatra的配置全局设定， 参见 <a
href="http://www.sinatrarb.com/configuration.html">选项和配置</a>，
也可以个别的被覆盖。</p>

<pre>set :haml, {:format =&gt; :html5 } # 默认的Haml输出格式是 :xhtml

get '/' do
  haml :index, :haml_options =&gt; {:format =&gt; :html4 } # 被覆盖，变成:html4
end</pre>

<a name='Erb%E6%A8%A1%E6%9D%BF'></a>
<h3>Erb模板</h3>

<pre>## 你需要在你的应用中引入 erb
require 'erb'

get '/' do
  erb :index
end</pre>

<p>渲染 <tt>./views/index.erb</tt></p>

<a name='Erubis'></a>
<h3>Erubis</h3>

<p>需要引入erubis gem/library以渲染 erubis 模板：</p>

<pre>## 你需要在你的应用中引入 erubis
require 'erubis'

get '/' do
  erubis :index
end</pre>

<p>渲染 <tt>./views/index.erubis</tt></p>

<a name='Builder%20%E6%A8%A1%E6%9D%BF'></a>
<h3>Builder 模板</h3>

<p>需要引入 builder gem/library 以渲染 builder templates：</p>

<pre>## 需要在你的应用中引入builder
require 'builder'

get '/' do
  builder :index
end</pre>

<p>渲染 <tt>./views/index.builder</tt>。</p>

<a name='Nokogiri%20%E6%A8%A1%E6%9D%BF'></a>
<h3>Nokogiri 模板</h3>

<p>需要引入 nokogiri gem/library 以渲染 nokogiri 模板：</p>

<pre>## 需要在你的应用中引入 nokogiri
require 'nokogiri'

get '/' do
  nokogiri :index
end</pre>

<p>渲染 <tt>./views/index.nokogiri</tt>。</p>

<a name='Sass%20%E6%A8%A1%E6%9D%BF'></a>
<h3>Sass 模板 </h3>

<p>需要引入 haml gem/library 以渲染 Sass 模板：</p>

<pre>## 需要在你的应用中引入 haml 或者 sass 
require 'sass'

get '/stylesheet.css' do
  sass :stylesheet
end</pre>

<p>渲染 <tt>./views/stylesheet.sass</tt>。</p>

<p><a
href="http://sass-lang.com/docs/yardoc/file.SASS_REFERENCE.html#options">Sass
的选项</a> 可以通过Sinatra选项全局设定， 参考 <a
href="http://www.sinatrarb.com/configuration.html">选项和配置（英文）</a>,
也可以在个体的基础上覆盖。</p>

<pre>set :sass, {:style =&gt; :compact } # 默认的 Sass 样式是 :nested

get '/stylesheet.css' do
  sass :stylesheet, :style =&gt; :expanded # 覆盖
end</pre>

<a name='Scss%20%E6%A8%A1%E6%9D%BF'></a>
<h3>Scss 模板 </h3>

<p>需要引入 haml gem/library 来渲染 Scss templates：</p>

<pre>## 需要在你的应用中引入 haml 或者 sass
require 'sass'

get '/stylesheet.css' do
  scss :stylesheet
end</pre>

<p>渲染 <tt>./views/stylesheet.scss</tt>。</p>

<p><a
href="http://sass-lang.com/docs/yardoc/file.SASS_REFERENCE.html#options">Scss的选项</a>
可以通过Sinatra选项全局设定， 参考 <a
href="http://www.sinatrarb.com/configuration.html">选项和配置（英文）</a>,
也可以在个体的基础上覆盖。</p>

<pre>set :scss, :style =&gt; :compact # default Scss style is :nested

get '/stylesheet.css' do
  scss :stylesheet, :style =&gt; :expanded # overridden
end</pre>

<a name='Less%20%E6%A8%A1%E6%9D%BF'></a>
<h3>Less 模板 </h3>

<p>需要引入 less gem/library 以渲染 Less 模板：</p>

<pre>## 需要在你的应用中引入 less
require 'less'

get '/stylesheet.css' do
  less :stylesheet
end</pre>

<p>渲染 <tt>./views/stylesheet.less</tt>。</p>

<a name='Liquid%20%E6%A8%A1%E6%9D%BF'></a>
<h3>Liquid 模板 </h3>

<p>需要引入 liquid gem/library 来渲染 Liquid 模板：</p>

<pre>## 需要在你的应用中引入 liquid
require 'liquid'

get '/' do
  liquid :index
end</pre>

<p>渲染 <tt>./views/index.liquid</tt>。</p>

<p>因为你不能在Liquid 模板中调用 Ruby 方法 (除了
<tt>yield</tt>) ， 你几乎总是需要传递locals给它：</p>

<pre>liquid :index, :locals =&gt; { :key =&gt; 'value' }</pre>

<a name='Markdown%20%E6%A8%A1%E6%9D%BF'></a>
<h3>Markdown 模板</h3>

<p>需要引入 rdiscount gem/library 以渲染 Markdown 模板：</p>

<pre>## 需要在你的应用中引入rdiscount
require &quot;rdiscount&quot;

get '/' do
  markdown :index
end</pre>

<p>渲染 <tt>./views/index.markdown</tt>  (<tt>md</tt> 和 <tt>mkd</tt>
也是合理的文件扩展名)。</p>

<p>在markdown中是不可以调用方法的，也不可以传递
locals给它。你因此一般会结合其他的渲染引擎来使用它：</p>

<pre>erb :overview, :locals =&gt; { :text =&gt; markdown(:introduction) }</pre>

<p>请注意你也可以从其他模板中调用 markdown 方法：</p>

<pre>%h1 Hello From Haml!
%p= markdown(:greetings)</pre>

<a name='Textile%20%E6%A8%A1%E6%9D%BF'></a>
<h3>Textile 模板</h3>

<p>需要引入 RedCloth gem/library 以渲染 Textile 模板：</p>

<pre>## 在你的应用中引入redcloth
require &quot;redcloth&quot;

get '/' do
  textile :index
end</pre>

<p>渲染 <tt>./views/index.textile</tt>。</p>

<p>在textile中是不可以调用方法的，也不可以传递
locals给它。你因此一般会结合其他的渲染引擎来使用它：</p>

<pre>erb :overview, :locals =&gt; { :text =&gt; textile(:introduction) }</pre>

<p>请注意你也可以从其他模板中调用textile方法：</p>

<pre>%h1 Hello From Haml!
%p= textile(:greetings)</pre>

<a name='RDoc%20%E6%A8%A1%E6%9D%BF'></a>
<h3>RDoc 模板</h3>

<p>需要引入 RDoc gem/library 以渲染RDoc模板：</p>

<pre>## 需要在你的应用中引入rdoc
require &quot;rdoc&quot;

get '/' do
  rdoc :index
end</pre>

<p>渲染 <tt>./views/index.rdoc</tt>。</p>

<p>在rdoc中是不可以调用方法的，也不可以传递
locals给它。你因此一般会结合其他的渲染引擎来使用它：</p>

<pre>erb :overview, :locals =&gt; { :text =&gt; rdoc(:introduction) }</pre>

<p>请注意你也可以从其他模板中调用rdoc方法：</p>

<pre>%h1 Hello From Haml!
%p= rdoc(:greetings)</pre>

<a name='Radius%20%E6%A8%A1%E6%9D%BF'></a>
<h3>Radius 模板</h3>

<p>需要引入 radius gem/library 以渲染 Radius 模板：</p>

<pre>## You'll need to require radius in your app
require 'radius'

get '/' do
  radius :index
end</pre>

<p>渲染 <tt>./views/index.radius</tt>。</p>

<p>因为你不能在Liquid 模板中调用 Ruby 方法 (除了
<tt>yield</tt>) ， 你几乎总是需要传递locals给它：</p>

<pre>radius :index, :locals =&gt; { :key =&gt; 'value' }</pre>

<a name='Markaby%20%E6%A8%A1%E6%9D%BF'></a>
<h3>Markaby 模板 </h3>

<p>需要引入markaby gem/library以渲染Markaby模板：</p>

<pre>##需要在你的应用中引入 markaby
require 'markaby'

get '/' do
  markaby :index
end</pre>

<p>渲染 <tt>./views/index.mab</tt>。</p>

<a name='CoffeeScript%20%E6%A8%A1%E6%9D%BF'></a>
<h3>CoffeeScript 模板</h3>

<p>需要引入 coffee-script gem/library 并在路径中存在 `coffee`
二进制文件以渲染 CoffeeScript 模板：</p>

<pre>## 需要在你的应用中引入coffee-script
require 'coffee-script'

get '/application.js' do
  coffee :application
end</pre>

<p>渲染 <tt>./views/application.coffee</tt>。</p>

<a name='%E5%86%85%E8%81%94%E6%A8%A1%E6%9D%BF%E5%AD%97%E7%AC%A6%E4%B8%B2'></a>
<h3>内联模板字符串</h3>

<pre>get '/' do
  haml '%div.title Hello World'
end</pre>

<p>渲染内联模板字符串。</p>

<a name='%E5%9C%A8%E6%A8%A1%E6%9D%BF%E4%B8%AD%E8%AE%BF%E9%97%AE%E5%8F%98%E9%87%8F'></a>
<h3>在模板中访问变量</h3>

<p>模板和路由执行器在同样的上下文求值。
在路由执行器中赋值的实例变量可以直接被模板访问。</p>

<pre>get '/:id' do
  @foo = Foo.find(params[:id])
  haml '%h1= @foo.name'
end</pre>

<p>或者，显式地指定一个本地变量的哈希：</p>

<pre>get '/:id' do
  foo = Foo.find(params[:id])
  haml '%h1= foo.name', :locals =&gt; { :foo =&gt; foo }
end</pre>

<p>典型的使用情况是在别的模板中按照部分模板的方式来渲染。</p>

<a name='%E5%86%85%E8%81%94%E6%A8%A1%E6%9D%BF'></a>
<h3>内联模板</h3>

<p>模板可以在源文件的末尾定义：</p>

<pre>require 'sinatra'

get '/' do
  haml :index
end

__END__

@@ layout
%html
  = yield

@@ index
%div.title Hello world!!!!!</pre>

<p>注意：引入sinatra的源文件中定义的内联模板才能被自动载入。
如果你在其他源文件中有内联模板，
需要显式执行调用<tt>enable :inline_templates</tt>。</p>

<a name='%E5%85%B7%E5%90%8D%E6%A8%A1%E6%9D%BF'></a>
<h3>具名模板</h3>

<p>模板可以通过使用顶层 <tt>template</tt> 方法定义：</p>

<pre>template :layout do
  &quot;%html\n  =yield\n&quot;
end

template :index do
  '%div.title Hello World!'
end

get '/' do
  haml :index
end</pre>

<p>如果存在名为“layout”的模板，该模板会在每个模板渲染的时候被使用。
你可以通过传送 <tt>:layout =&gt; false</tt>来禁用。</p>

<pre>get '/' do
  haml :index, :layout =&gt; !request.xhr?
end</pre>

<a name='%E8%BE%85%E5%8A%A9%E6%96%B9%E6%B3%95'></a>
<h2>辅助方法</h2>

<p>使用顶层的 <tt>helpers</tt> 方法来定义辅助方法，
以便在路由处理器和模板中使用：</p>

<pre>helpers do
  def bar(name)
    &quot;#{name}bar&quot;
  end
end

get '/:name' do
  bar(params[:name])
end</pre>

<a name='%E8%BF%87%E6%BB%A4%E5%99%A8'></a>
<h2>过滤器</h2>

<p>前置过滤器在每个请求前，在请求的上下文环境中被执行，
而且可以修改请求和响应。
在过滤器中设定的实例变量可以被路由和模板访问：</p>

<pre>before do
  @note = 'Hi!'
  request.path_info = '/foo/bar/baz'
end

get '/foo/*' do
  @note #=&gt; 'Hi!'
  params[:splat] #=&gt; 'bar/baz'
end</pre>

<p>后置过滤器在每个请求之后，在请求的上下文环境中执行，
而且可以修改请求和响应。
在前置过滤器和路由中设定的实例变量可以被后置过滤器访问：</p>

<pre>after do
  puts response.status
end</pre>

<p>过滤器可以可选地带有范式，
只有请求路径满足该范式时才会执行：</p>

<pre>before '/protected/*' do
  authenticate!
end

after '/create/:slug' do |slug|
  session[:last_slug] = slug
end</pre>

<a name='%E6%8C%82%E8%B5%B7'></a>
<h2>挂起</h2>

<p>要想直接地停止请求，在过滤器或者路由中使用：</p>

<pre>halt</pre>

<p>你也可以指定挂起时的状态码：</p>

<pre>halt 410</pre>

<p>或者消息体：</p>

<pre>halt 'this will be the body'</pre>

<p>或者两者;</p>

<pre>halt 401, 'go away!'</pre>

<p>也可以带消息头：</p>

<pre>halt 402, {'Content-Type' =&gt; 'text/plain'}, 'revenge'</pre>

<a name='%E8%AE%A9%E8%B7%AF'></a>
<h2>让路</h2>

<p>一个路由可以放弃处理，将处理让给下一个匹配的路由，使用
<tt>pass</tt>：</p>

<pre>get '/guess/:who' do
  pass unless params[:who] == 'Frank'
  'You got me!'
end

get '/guess/*' do
  'You missed!'
end</pre>

<p>路由代码块被直接退出，控制流继续前进到下一个匹配的路由。
如果没有匹配的路由，将返回404。</p>

<a name='%E8%AE%BF%E9%97%AE%E8%AF%B7%E6%B1%82%E5%AF%B9%E8%B1%A1'></a>
<h2>访问请求对象</h2>

<p>传入的请求对象可以在请求层（过滤器，路由，错误处理）通过
`request` 方法被访问：</p>

<pre># 在 http://example.com/example 上运行的应用
get '/foo' do
  request.body              # 被客户端设定的请求体（见下）
  request.scheme            # &quot;http&quot;
  request.script_name       # &quot;/example&quot;
  request.path_info         # &quot;/foo&quot;
  request.port              # 80
  request.request_method    # &quot;GET&quot;
  request.query_string      # &quot;&quot;
  request.content_length    # request.body的长度
  request.media_type        # request.body的媒体类型
  request.host              # &quot;example.com&quot;
  request.get?              # true (其他动词也具有类似方法)
  request.form_data?        # false
  request[&quot;SOME_HEADER&quot;]    # SOME_HEADER header的值
  request.referer           # 客户端的referer 或者 '/'
  request.user_agent        # user agent (被 :agent 条件使用)
  request.cookies           # 浏览器 cookies 哈希
  request.xhr?              # 这是否是ajax请求？
  request.url               # &quot;http://example.com/example/foo&quot;
  request.path              # &quot;/example/foo&quot;
  request.ip                # 客户端IP地址
  request.secure?           # false
  request.env               # Rack中使用的未处理的env哈希
end</pre>

<p>一些选项，例如 <tt>script_name</tt> 或者 <tt>path_info</tt> 
也是可写的：</p>

<pre>before { request.path_info = &quot;/&quot; }

get &quot;/&quot; do
  &quot;all requests end up here&quot;
end</pre>

<p><tt>request.body</tt> 是一个IO或者StringIO对象：</p>

<pre>post &quot;/api&quot; do
  request.body.rewind  # 如果已经有人读了它
  data = JSON.parse request.body.read
  &quot;Hello #{data['name']}!&quot;
end</pre>

<a name='%E9%85%8D%E7%BD%AE'></a>
<h2>配置</h2>

<p>运行一次，在启动的时候，在任何环境下：</p>

<pre>configure do
  ...
end</pre>

<p>只当环境 (RACK_ENV environment 变量) 被设定为
<tt>:production</tt>的时候运行：</p>

<pre>configure :production do
  ...
end</pre>

<p>当环境被设定为 <tt>:production</tt> 或者
<tt>:test</tt>的时候运行：</p>

<pre>configure :production, :test do
  ...
end</pre>

<a name='%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86'></a>
<h2>错误处理</h2>

<p>错误处理在与路由和前置过滤器相同的上下文中运行，
这意味着你可以使用许多好东西，比如 <tt>haml</tt>,
<tt>erb</tt>, <tt>halt</tt>，等等。</p>

<a name='%E6%9C%AA%E6%89%BE%E5%88%B0'></a>
<h3>未找到</h3>

<p>当一个 <tt>Sinatra::NotFound</tt> 错误被抛出的时候，
或者响应状态码是404，<tt>not_found</tt> 处理器会被调用：</p>

<pre>not_found do
  'This is nowhere to be found'
end</pre>

<a name='%E9%94%99%E8%AF%AF'></a>
<h3>错误</h3>

<p><tt>error</tt>
处理器，在任何路由代码块或者过滤器抛出异常的时候会被调用。
异常对象可以通过<tt>sinatra.error</tt> Rack 变量获得：</p>

<pre>error do
  'Sorry there was a nasty error - ' + env['sinatra.error'].name
end</pre>

<p>自定义错误：</p>

<pre>error MyCustomError do
  'So what happened was...' + request.env['sinatra.error'].message
end</pre>

<p>那么，当这个发生的时候：</p>

<pre>get '/' do
  raise MyCustomError, 'something bad'
end</pre>

<p>你会得到：</p>

<pre>So what happened was... something bad</pre>

<p>另一种替代方法是，为一个状态码安装错误处理器：</p>

<pre>error 403 do
  'Access forbidden'
end

get '/secret' do
  403
end</pre>

<p>或者一个范围：</p>

<pre>error 400..510 do
  'Boom'
end</pre>

<p>在运行在development环境下时，Sinatra会安装特殊的
<tt>not_found</tt> 和 <tt>error</tt> 处理器。</p>

<a name='%E5%AA%92%E4%BD%93%E7%B1%BB%E5%9E%8B'></a>
<h2>媒体类型</h2>

<p>当使用 <tt>send_file</tt>
或者静态文件的适合，你的媒体类型可能
Sinatra并不理解。使用 <tt>mime_type</tt>
通过文件扩展名来注册它们：</p>

<pre>mime_type :foo, 'text/foo'</pre>

<p>你也可以通过 <tt>content_type</tt> 辅助方法使用：</p>

<pre>content_type :foo</pre>

<a name='Rack%20%E4%B8%AD%E9%97%B4%E4%BB%B6'></a>
<h2>Rack 中间件</h2>

<p>Sinatra 依靠 <a href="http://rack.rubyforge.org/">Rack</a>, 
一个面向Ruby web框架的最小标准接口。
Rack的一个最有趣的面向应用开发者的能力是支持“中间件”——坐落在服务器和你的应用之间，
监视 并/或 操作HTTP请求/响应以
提供多样类型的常用功能。</p>

<p>Sinatra 让建立Rack中间件管道异常简单， 通过顶层的
<tt>use</tt> 方法：</p>

<pre>require 'sinatra'
require 'my_custom_middleware'

use Rack::Lint
use MyCustomMiddleware

get '/hello' do
  'Hello World'
end</pre>

<p><tt>use</tt> 的语义和在<a
href="http://rack.rubyforge.org/doc/classes/Rack/Builder.html">Rack::Builder</a>
DSL (在rack文件中最频繁使用)
中定义的完全一样。例如，<tt>use</tt> 方法 接受
多个/可变 参数，包括代码块：</p>

<pre>use Rack::Auth::Basic do |username, password|
  username == 'admin' &amp;&amp; password == 'secret'
end</pre>

<p>Rack中分布有多样的标准中间件，针对日志，
调试，URL路由，认证和session处理。
Sinatra会自动使用这里面的大部分组件，
所以你一般不需要显示地 <tt>use</tt> 他们。</p>

<a name='%E6%B5%8B%E8%AF%95'></a>
<h2>测试</h2>

<p>Sinatra的测试可以使用任何基于Rack的测试程序库或者框架来编写。
<a href="http://gitrdoc.com/brynary/rack-test">Rack::Test</a>
是推荐候选：</p>

<pre>require 'my_sinatra_app'
require 'test/unit'
require 'rack/test'

class MyAppTest &lt; Test::Unit::TestCase
  include Rack::Test::Methods

  def app
    Sinatra::Application
  end

  def test_my_default
    get '/'
    assert_equal 'Hello World!', last_response.body
  end

  def test_with_params
    get '/meet', :name =&gt; 'Frank'
    assert_equal 'Hello Frank!', last_response.body
  end

  def test_with_rack_env
    get '/', {}, 'HTTP_USER_AGENT' =&gt; 'Songbird'
    assert_equal &quot;You're using Songbird!&quot;, last_response.body
  end
end</pre>

<p>请注意: 内置的 Sinatra::Test 模块和 Sinatra::TestHarness 类 在
0.9.2 版本已废弃。</p>

<a name='Sinatra::Base%20-%20%E4%B8%AD%E9%97%B4%E4%BB%B6%EF%BC%8C%E7%A8%8B%E5%BA%8F%E5%BA%93%E5%92%8C%E6%A8%A1%E5%9D%97%E5%8C%96%E5%BA%94%E7%94%A8'></a>
<h2>Sinatra::Base - 中间件，程序库和模块化应用</h2>

<p>把你的应用定义在顶层，对于微型应用这会工作得很好，但是在
构建可复用的组件时候会带来客观的不利，
比如构建Rack中间件，Rails
metal，带有服务器组件的简单程序库，
或者甚至是Sinatra扩展。顶层的DSL污染了Object命名空间并
假定了一个微型应用风格的配置 (例如,
单一的应用文件， ./public 和 ./views
目录，日志，异常细节页面，等等）。 这时应该让
Sinatra::Base 走到台前了：</p>

<pre>require 'sinatra/base'

class MyApp &lt; Sinatra::Base
  set :sessions, true
  set :foo, 'bar'

  get '/' do
    'Hello world!'
  end
end</pre>

<p>MyApp 类是一个独立的Rack组件，可以扮演
Rack中间件，一个Rack应用，或者 Rails metal。你可以从rackup
+config.ru文件 <tt>use</tt> 或者 <tt>run</tt> 这个类；或者，
直接控制作为程序库提供的服务器组件：</p>

<pre>MyApp.run! :host =&gt; 'localhost', :port =&gt; 9090</pre>

<p>Sinatra::Base子类可用的方法实际上就是
通过顶层DSL可用的方法。大部分顶层应用可以通过两个改变
转换成Sinatra::Base组件：</p>
<ul><li>
<p>你的文件应当引入 <tt>sinatra/base</tt> 而不是 <tt>sinatra</tt>;
否则，所有的Sinatra的 DSL 方法将会被引进到
主命名空间。</p>
</li><li>
<p>把你的应用的路由，错误处理，过滤器和选项放在
一个Sinatra::Base的子类中。</p>
</li></ul>

<p><tt>+Sinatra::Base+</tt>
是一张白纸。大部分的选项默认是禁用的，
包含内置的服务器。参见 <a
href="http://sinatra.github.com/configuration.html">选项和配置</a>
查看可用选项的具体细节和他们的行为。</p>

<a name='%E6%8A%8ASinatra%E5%BD%93%E6%88%90%E4%B8%AD%E9%97%B4%E4%BB%B6%E6%9D%A5%E4%BD%BF%E7%94%A8'></a>
<h3>把Sinatra当成中间件来使用</h3>

<p>不仅Sinatra有能力使用其他的Rack中间件，任何Sinatra
应用程序都可以反过来自身被当作中间件，被加在任何Rack断电前面。
这个端点可以是任何Sinatra应用，或者任何基于Rack的应用程序
(Rails/Ramaze/Camping/…)。</p>

<pre>require 'sinatra/base'

class LoginScreen &lt; Sinatra::Base
  enable :sessions

  get('/login') { haml :login }

  post('/login') do
    if params[:name] = 'admin' and params[:password] = 'admin'
      session['user_name'] = params[:name]
    else
      redirect '/login'
    end
  end
end

class MyApp &lt; Sinatra::Base
  # 在前置过滤器前运行中间件
  use LoginScreen

  before do
    unless session['user_name']
      halt &quot;Access denied, please &lt;a href='/login'&gt;login&lt;/a&gt;.&quot;
    end
  end

  get('/') { &quot;Hello #{session['user_name']}.&quot; }
end</pre>

<a name='%E5%8F%98%E9%87%8F%E5%9F%9F%E5%92%8C%E7%BB%91%E5%AE%9A'></a>
<h2>变量域和绑定</h2>

<p>当前所在的变量域决定了哪些方法和变量是可用的。</p>

<a name='%E5%BA%94%E7%94%A8/%E7%B1%BB%20%E5%8F%98%E9%87%8F%E5%9F%9F'></a>
<h3>应用/类 变量域</h3>

<p>每个Sinatra应用相当与Sinatra::Base的一个子类。
如果你在使用顶层DSL(<tt>require
'sinatra'</tt>)，那么这个类就是
Sinatra::Application，或者这个类就是你显式创建的子类。
在类层面，你具有的方法类似于 `get` 或者
`before`，但是你不能访问 `request` 对象或者 `session`,
因为对于所有的请求， 只有单一的应用类。</p>

<p>通过 `set` 创建的选项是类层面的方法：</p>

<pre>class MyApp &lt; Sinatra::Base
  # 嘿，我在应用变量域！
  set :foo, 42
  foo # =&gt; 42

  get '/foo' do
    # 嘿，我不再处于应用变量域了！
  end
end</pre>

<p>在下列情况下你将拥有应用变量域的绑定：</p>
<ul><li>
<p>在应用类中</p>
</li><li>
<p>在扩展中定义的方法</p>
</li><li>
<p>传递给 `helpers` 的代码块</p>
</li><li>
<p>用作`set`值的过程/代码块</p>
</li></ul>

<p>你可以访问变量域对象（就是应用类）就像这样：</p>
<ul><li>
<p>通过传递给代码块的对象 (<tt>configure { |c| ... }</tt>)</p>
</li><li>
<p>在请求变量域中使用`settings`</p>
</li></ul>

<a name='%E8%AF%B7%E6%B1%82/%E5%AE%9E%E4%BE%8B%20%E5%8F%98%E9%87%8F%E5%9F%9F'></a>
<h3>请求/实例 变量域</h3>

<p>对于每个进入的请求，一个新的应用类的实例会被创建
所有的处理器代码块在该变量域被运行。在这个变量域中，
你可以访问 `request` 和 `session`
对象，或者调用渲染方法比如 `erb` 或者
`haml`。你可以在请求变量域当中通过`settings`辅助方法
访问应用变量域：</p>

<pre>class MyApp &lt; Sinatra::Base
  # 嘿，我在应用变量域!
  get '/define_route/:name' do
    # 针对 '/define_route/:name' 的请求变量域
    @value = 42

    settings.get(&quot;/#{params[:name]}&quot;) do
      # 针对 &quot;/#{params[:name]}&quot; 的请求变量域
      @value # =&gt; nil (并不是相同的请求)
    end

    &quot;Route defined!&quot;
  end
end</pre>

<p>在以下情况将获得请求变量域：</p>
<ul><li>
<p>get/head/post/put/delete 代码块</p>
</li><li>
<p>前置/后置 过滤器</p>
</li><li>
<p>辅助方法</p>
</li><li>
<p>模板/视图</p>
</li></ul>

<a name='%E4%BB%A3%E7%90%86%E5%8F%98%E9%87%8F%E5%9F%9F'></a>
<h3>代理变量域</h3>

<p>代理变量域只是把方法转送到类变量域。可是，
他并非表现得100%类似于类变量域,
因为你并不能获得类的绑定: 
只有显式地标记为供代理使用的方法才是可用的，
而且你不能和类变量域共享变量/状态。(解释：你有了一个不同的
`self`)。 你可以显式地增加方法代理，通过调用
<tt>Sinatra::Delegator.delegate :method_name</tt>。</p>

<p>在以下情况将获得代理变量域：</p>
<ul><li>
<p>顶层的绑定，如果你做过 <tt>require &quot;sinatra&quot;</tt></p>
</li><li>
<p>在扩展了 `Sinatra::Delegator` mixin的对象</p>
</li></ul>

<p>自己在这里看一下代码:  <a
href="http://github.com/sinatra/sinatra/blob/ceac46f0bc129a6e994a06100aa854f606fe5992/lib/sinatra/base.rb#L1128">Sinatra::Delegator
mixin</a> 已经 <a
href="http://github.com/sinatra/sinatra/blob/ceac46f0bc129a6e994a06100aa854f606fe5992/lib/sinatra/main.rb#L28">被包含进了主命名空间</a>。</p>

<a name='%E5%91%BD%E4%BB%A4%E8%A1%8C'></a>
<h2>命令行</h2>

<p>Sinatra 应用可以被直接运行：</p>

<pre>ruby myapp.rb [-h] [-x] [-e ENVIRONMENT] [-p PORT] [-o HOST] [-s HANDLER]</pre>

<p>选项是：</p>

<pre>-h # help
-p # 设定端口 (默认是 4567)
-o # 设定主机名 (默认是 0.0.0.0)
-e # 设定环境 (默认是 development)
-s # 限定 rack 服务器/处理器 (默认是 thin)
-x # 打开互斥标记锁 (默认是 off)</pre>

<a name='%E7%B4%A7%E8%BF%BD%E5%89%8D%E6%B2%BF'></a>
<h2>紧追前沿</h2>

<p>如果你喜欢使用 Sinatra
的最新鲜的代码，创建一个本地克隆 ，
把<tt>sinatra/lib</tt> 目录添加到
<tt>LOAD_PATH</tt>后运行你的应用：</p>

<pre>cd myapp
git clone git://github.com/sinatra/sinatra.git
ruby -Isinatra/lib myapp.rb</pre>

<p>另一种方法是，你也可以在你的应用中，添加
<tt>sinatra/lib</tt> 目录到 <tt>LOAD_PATH</tt>：</p>

<pre>$LOAD_PATH.unshift File.dirname(__FILE__) + '/sinatra/lib'
require 'rubygems'
require 'sinatra'

get '/about' do
  &quot;I'm running version &quot; + Sinatra::VERSION
end</pre>

<p>在未来，要更新Sinatra源代码：</p>

<pre>cd myproject/sinatra
git pull</pre>

<a name='%E6%9B%B4%E5%A4%9A'></a>
<h2>更多</h2>
<ul><li>
<p><a href="http://www.sinatrarb.com/">项目主页（英文）</a> -
更多的文档， 新闻，和其他资源的链接。</p>
</li><li>
<p><a href="http://www.sinatrarb.com/contributing">贡献</a> -
找到了一个bug？ 需要帮助？有了一个 patch?</p>
</li><li>
<p><a href="http://github.com/sinatra/sinatra/issues">问题追踪</a></p>
</li><li>
<p><a href="http://twitter.com/sinatra">Twitter</a></p>
</li><li>
<p><a href="http://groups.google.com/group/sinatrarb/topics">邮件列表</a></p>
</li><li>
<p><a href="irc://chat.freenode.net/#sinatra">IRC: #sinatra</a> on <a
href="http://freenode.net">freenode.net</a></p>
</li></ul>
